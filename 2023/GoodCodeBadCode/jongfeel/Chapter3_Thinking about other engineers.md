## 3장 다른 개발자와 코드 계약

<pre>
논의내용)
<b>책에서 제시한 다른 개발자를 위한 코드 작성하기 방법 외에 자신이 썼던 방법(물론 주석 제외)이 뭐가 있는지 얘기해 보자.</b>

내가 쓰는 최종 단계는 주로 읽을 수 있는 코드 리팩터링을 자주 하는 것이 좋은 방향이라고 본다.
주석에 대한 문제점은 이책 외에도 많이 언급하고 있으므로 쓰지 않고 있고
어색하지 않은 영어 단어와 문장 그리고 길지 않게 코드를 쓰고 함수로 추상화 하는 작업 정도면 어느 정도 해결이 가능하긴 하다.
</pre>

### 3.1 자신의 코드와 다른 개발자의 코드

개발자들 끼리 서로 작성한 코드를 바탕으로 더 코드를 작성한다.
추상화 계층이 분리된 해결 코드는 전혀 생각지 못한 다른 문제에서 재사용이 가능하다.

코품질 코드를 작성할 때 고려 사항은 다른 개발자가 변경하거나 코드와 상호작용할 때 발생할 수 있는 문제는 없는지
또 발생한다면 그 문제를 어떻게 완화할 수 있을지를 이해하고 선제적으로 조치하는 것이다.
다른 개발자를 고려하지 않고는 고품질의 코드를 작성할 수 없다.

#### 3.1.1 자신에게 분명하다고 해서 다른 사람에게도 분명한 것은 아니다(Things that are obvious to you are not obvious to others)

어느 시점에 이르면 다른 개발자가 내 코드와 상호작용하거나, 변경하거나, 의존하고 있는 코드를 변경해야 할 수도 있다.

코드가 어떻게 사용되어야 하는지, 무엇을 하는지, 그리고 왜 그 일을 하고 있는지 설명하는 것이 유용하다.
주석을 많이 쓰라는 의미가 아니라, 코드를 이해하기 쉽고 코드 자체로 설명이 되게 하는 것이 좋은 방법이다.

#### 3.1.2 다른 개발자는 부지중에 여러분의 코드를 망가뜨릴 수 있다(Other engineers will inadvertently try to break your code)

코드는 계속 변화하고 끊임없이 영향을 받고 변화한다.
다른 개발자는 그 코드가 뭔지 잘 알지 못할 수 있고, 의도치 않게 코드를 망가뜨리거나 오용하는 방식으로 코드를 추가/수정할 수 있다.

다른 개발자의 코드 변경으로 코드가 작동하지 않거나 오용하는 결과를 가져온다면 문제를 해결하기 전까지 코드를 병합하면 안된다.
신뢰할 만한 방법 두 가지로 문제가 생겼을 때 코드 컴파일이 중지되거나 테스트가 실패하도록 만든다.

#### 3.1.3 시간이 지나면 자신의 코드를 기억하지 못한다(In time, you will forget about your own code)

1년 후에 새로운 기능을 추가해야 하거나, 자신의 코드에서 발견된 버그를 해결해야 한다면 자신이 작성한 코드인데도 기억을 못할 수 있다.
1~2년 전에 작성한 코드를 다시 들여다보는 일은 다른 사람이 작성한 코드를 보는 것과 크게 다르지 않다.

자신의 코드가 이해하기 쉬워야 하고, 잘 작동하는 코드에 버그가 발생하는 것이 어려워야 한다.
이렇게 하는 것은 미래의 자신에게 유익한 일이다.

### 3.2 여러분이 작성한 코드의 사용법을 다른 사람들은 어떻게 아는가?

이름과 데이터 유형을 확인하는 것이 문서를 읽는 것 보다 더 신뢰할 만하다.

#### 3.2.1 이름 확인

코드를 사용할 때 이름을 무시하기는 매우 어렵다.
이름을 잘 짓는 것은 자신의 코드를 다른 개발자가 어떻게 사용해야 하는지에 대해 가장 잘 전달할 수 있는 방법이다.

#### 3.2.2 데이터 유형 확인

유형 시스템을 사용하는 언어로 코드를 작성하는 것은 다른 개발자가 코드를 오용하거나 오작동할 수 없도록 하기 위한 좋은 방법이다.

#### 3.2.3 문서 읽기

다른 개발자가 코드를 올바르게 사용하도록 하기 위한 방법으로 어느 정도까지만 신뢰할 수 있다.

- 읽을 것이라는 보장이 없다
- 읽더라도 잘못 해석한다.
- 업데이트가 제대로 안되어 있다

```
의견)
보통 업데이트가 잘 안되어 있기 때문에 읽지 않는 게 맞다고 본다.
```

#### 3.2.4 직접 물어보기

코드를 작성한지 얼마 안됐다면 효과적이지만, 다음의 이유로 신뢰하기 어렵다

- 코드가 많을 수록 질문에 답하는 시간이 많아진다
- 코드 작성자가 휴가를 갔다면?
- 1년이 지나면 기억을 못하기 때문에 제한된 기간 안에서면 효과가 있다
- 코드 작성자가 회사를 떠나서, 코드 작성 방법에 대한 지식이 사라진다

#### 3.2.5 코드를 살펴보는 것

'내 코드의 사용 방법을 이해하고 싶으면 코드 안에서 어떻게 구현됐는지 읽어보면 되지 뭐' 라는 자세는 상황을 악화시킨다

```
의견)
매우 공감한다 코드를 쓰는 자기 자신은 이해하지만 남도 이 코드를 읽으면 이해할 수 있을 거라 생각하는게 문제이기도 하다 
그래서 코드를 작성하기 전에 만들었던 작은 문서(애자일의 유저 스토리)와 항상 연결 시켜서 무슨 작업을 하기 위해 이 코드가 작성됐는지 연결 시키는 게 좋은 방법이라고 본다
```

### 3.3 코드 계약

계약에 의한 프로그래밍programming by contract
계약에 의한 디자인design by contract

코드 간의 상호작용을 계약으로 이해
계약으로 정의되기 때문에 명확하고 예상과 다르게 실행되는 것이 없다.

- 선결 조건precondition: 코드를 호출하기 전에 사실이어야 하는 것
- 사후 조건postcondition: 코드가 호출된 후에 사실이어야 하는 것
- 불변 사항invariant: 코드가 호출되기 전과 후에 시스템 상태를 비교해서 변경되지 않아야 하는 사항

코드를 작성할 때 만들어지는 계약의 내용이 무엇일지 그리고 어떻게 하면 코드를 사용하는 사람이 계약을 파악하고 따라갈 수 있을지에 대해 생각하는 것이 중요하다.

```
의견)
계약에 의한 프로그래밍은 실용주의 프로그래머에서도 나온 내용으로 정말로 한번 만들어야 겠다는 생각을 또 하게 된다.
곧 이직할 팀에서 한번 practice를 만들어 봐야 할 것 같다
```

### 3.3.1 계약의 세부 조항

- 주석문과 문서: 꼼꼼하게 읽어봐야 하는 것임에도 실제로는 잘 읽지 않는다. 개발자는 이 사실을 실용적인 관점에서 봐야 한다.
- 비검사 예외unchecked exception: 주석문에 나열되어 있다면 세부 조항이다. 어떤 때는 세부 조항에도 나와 있지 않을 수도 있다.

### 3.3.2 세부 조항에 너무 의존하지 말라

코드 계약을 전달할 때 세부 조항을 사용하는 것은 신뢰할 만한 방법이 아니다.
세부 조항에 너무 많이 의존하면 오용하기 쉬운 취약한 코드가 될 가능성이 크고, 예상과 다르게 동작하기 쉽다.

세부 조항에 의존하는 것을 피할 수 없는 경우도 있다.
문서화 된 세부조항이 필요하고 읽게 해야 하지만 읽지 않을 가능성이 크거나 시간이 흐르면서 업데이트가 안될 가능성이 크기 때문에 문서화는 이상적인 방법은 아니다.

**세부 조항을 제거하는 방법**

세부 조항은 너무 쉽게 간과되기 때문에 다른 사람들이 그것을 읽어볼 것이라고 기대하기 어렵다.
코드에서도 다른 개발자가 코드를 올바르게 사용하기 위해 세부 조항에 의존하기보다 잘못된 일을 하는 것을 처음부터 불가능하게 만드는 것이 좋다.

### 3.4 체크 및 어서션

컴파일러를 사용하여 코드 계약을 확인하는 것에 대한 대안으로 런타임 검사를 사용할 수 있다.

#### 3.4.1 체크

체크check는 코드 계약이 준수되었는지(입력 매개변수에 대한 제약 조건 또는 수행해야 할 설정에 대한 제약 등) 확인하기 위한 추가 로직이며,
준수되지 않을 경우 체크는 실패를 유발하는 오류(또는 이와 유사한 것)를 생성하는데,
이 실패는 명백해서 놓치고 넘어가는 것이 불가능 하다. (체크는 신속한 실패failing fast와 밀접한 관련이 있다)

- 전체 조건 검사: 입력 인수가 올바르거나, 초기화가 수행되었거나, 일부 코드를 실행하기 전에 시스템이 유효한 상태인지 확인하는 경우
- 사후 상태 검사: 반환값이 올바르거나 일부 코드를 실행한 후 시스템이 유효한 상태인지 확인하는 경우

체크를 사용할 때 기대하는 것은 코드가 오용되서 배포 되기 전에 개발 단계 혹은 테스트 단계에서 발견하고 수정하는 것이다.

코드 계약에서 세부 조항은 피할 수 없다면, 계약 준수를 확인하기 위해 체크를 추가하는 것이 좋다.
하지만 가능하다면 세부 조항은 피하는 것이 바람직하다.
코드에 체크가 많이 있으면 세부 조항을 없애는 것을 생각해볼 수 있다.

#### 3.4.2 어서션

어서션assertion은 코드 계약을 준수하도록 강제하기 위한 방법.
어서션이 체크와 다른 점은 배포를 위해 빌드할 때 컴파일에서 제외된다는 점이고,
코드가 실제 서비스 환경에서 사용될 때 실패를 명백하게 보여주지 않는다는 점이다.

배포시 컴파일 하지 않는 이유는 다음과 같다

- 성능 향상을 위해
- 코드 오류 발생률을 낮추기 위해

코드 계약에 세부 조항이 있을 때 어서션을 사용하면 좋다.
하지만 애초에 세부 조항을 피하는 것이 더 바람직하다.

### 요약

- Code bases are in a constant state of flux with multiple engineers typically making constant changes
- It’s useful to think about how other engineers might break or misuse code and engineer it in a way that minimizes the chances of this or makes it impossible
- When we write code, we are invariably creating some kind of coding contract. This can contain things are are unmistakably obvious and things that are more like small print
- Small print in coding contracts is not a reliable way to ensure other engineers adhere to the contract. Making things unmistakably obvious is usually a better approach