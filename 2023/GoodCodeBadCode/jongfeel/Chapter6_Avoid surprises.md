## 6장 예측 가능한 코드를 작성하라

개발자는 코드를 사용하는 방법에 대한 정신 모델(mental model)을 구축한다.
mental model은 코드 계약, 사전 지식, 적용 가능한 공통 패러다임에 근거해서 만들어진다.
코드가 하는 일이 mental model과 일치하지 않는다면, 예측에서 벗어나는 기분 나쁜 일이 일어날 가능성이 크다.

예측 가능한 코드를 작성하는 것은 무언가를 분명하게 하는 것일 때가 많다.
코드의 동작이 실제 일어날 것이라고 생각하는 것과 일치하지 않는다면 문제가 생기므로
다른 개발자에게 확실하게 알려야 한다.

<pre>
논의내용)
예측 가능한 코드는 가독성과도 연관되어 있다.
<b>예측 가능한 코드를 짜기 위해 실천했던 방법이 있었다면 하나 정도 얘기</b>를 해 보면 좋을 것 같다.

책의 예시 처럼 매직값 같은 경우는 다른 책에도 많이 언급하고 있었기 때문에 추상화된 함수나 상수로 구현하려고 했던 건 기본적은 실천법이었던 것 같다.

추가로 6.6절에 있는 <b>열거형에 대한 논란도 상당히 재미있었는데, 자신은 어떤 주장을 하는 쪽에 속하는지 얘기</b>해 봐도 좋을 것 같다.

아마 대부분 열거형을 쓰는 쪽일 것 같은데, 사실 다형성을 활용해서 특정 값을 객체 안에 캡슐화 시킨다는 생각은 정말 객체지향 빠돌이가 아니면 생각하지 못할 부분인 것 같다. 이렇게 만드는 사람이 정말 있을까? 
(그런데 그 주장의 근거가 아주 못할 짓은 아닌게, 상당히 객체지향적인 마인드로 만들어서 쓴다면 단일 인터페이스 하나로 열거형 쯤은 안써도 될 수 있는 수준으로 아름답게 쓸 수 있을 것 같긴 하다)
</pre>

### 6.1 매직값을 반환하지 말아야 한다

매직값magic value은 함수의 정상적인 반환 유형에 적합하지만 특별한 의미를 가지고 있다.
일반적인 예로 -1을 반환하는 것은 값이 없거나 오류가 발생했다는 걸 나타낸다.

매직값은 문법적으로 반환 유형에만 맞춘 것으로 동작은 하지만 특별한 의미를 인지하지 못하고
정상적인 반환값으로 오인하기 쉽다.

#### 6.1.1 매직값은 버그를 유발할 수 있다

과거 레거시 코드나 indexOf와 같은 내장 함수들이 -1을 반환한다.
계속해서 이런 코드를 작업 중이거나, 신중하게 최적화해야 하는 코드가 있다면 계속 쓸 이유가 있지만
일반적으로는 매직값을 반환하면 예측을 벗어날 위험이 있으므로 사용하지 않는 것이 바람직하다.

예제 나이를 반환하는데 int 값을 사용하고 이 나이의 평균을 구하는데 잘못된 나이에 대해 -1이 반환된다면 문제가 생길 수 있다.
즉 나이가 옵셔널 널을 허용하는 int? 값이라서 내부적으로 null이 체크가 됐을 때 -1을 반환한다면 예측 불가능한 코드가 된다.

그리고 단위 테스트가 이 문제를 발견하지 못할 수 있는데
단위 테스트에 사용하는 코드는 모든 인스턴스가 정상적인 나이를 가지고 있을 가능성이 높기 때문이다.

```
의견)
-1을 반환하는 기본 내장 함수들에 대해 특별히 잘못된 매직값이다라고 의식하지는 않았는데
조금 더 예측 가능한 코드를 위해 책에서 제시하는 널, 옵셔널, 오류를 사용하는게 좋겠다는 생각이 든다.
(생각이라 읽고 설득이라 씀)
```

#### 6.1.2 해결책: 널, 옵셔널 또는 오류를 반환하라

값이 없을 수 있는 경우에는 코드 계약의 명백한 부분에서 확인할 수 있도록 한다.
널 안전성을 지원하는 경우 널이 가능한 유형을 반환하고,
널 안전성을 지원하지 않는 경우에는 옵셔널 값을 반환한다.

널이 반환되면 컴파일러 오류를 발생시켜서 이 함수를 작성한 개발자가 코드에 잠재적인 버그가 있다는 것을 깨닫게 한다.
널값이나 비어 있는 옵셔널을 반환하는 것의 단점은 값이 없는 이유를 명시적으로 전달하지 않는다는 점인데,
사용자의 나이가 값을 제공하지 않았기 때문에 널인지,
혹은 시스템에서 오류가 발생하여 널인지 알 수 없다.
이럴 때는 오류 전달 기법을 사용하는 걸 고려해야 한다.

> 널이 가능한 반환 유형은 호출하는 쪽에 부담을 주지 않는가?
이것에 대한 짧은 대답은 종종 '그렇다' 이다. 널을 처리하기 위한 노력으로 널 객체 패턴을 사용할 수 있고, Null 관련 예외 처리에 대한 위험 부담도 있다.

#### 6.1.3 때때로 매직값이 우연히 발생할 수 있다

정수 리스트에서 최소값을 찾는 예제를 통해 확인

``` java
Int minValue(List<Int> values)
```

리스트가 비어 있으면 매직값(Int.MAX_VALUE)를 반환하는데 우연히 반환되는 것이 아닐 수 있다.

- 빈 목록에 대해 최소값이 의미가 없다는 걸 알고 있다면 어떤 값이 반환되도 중요하지 않다
- Int.MAX_VALUE 보다 더 큰 정수가 없으므로 반환하기에 적합하다.

이런 주장은 함수가 어떻게 호출되고 결과가 어떨지에 대해 가정을 하는 것인데, 그 가정이 잘못된 것이라면 코드는 예측을 벗어나는 동작을 하게 된다.

따라서 minValue() 함수의 경우 널값이나 빈 옵셔널을 반환하거나 오류 전달을 하는 것이 더 낫고,
호출하는 쪽에서 어떤 입력에 대해서는 이 함수의 값이 계산되지 않는 다는 사실을 알리는게 좋다.

어쨌든 매직값은 예측을 벗어나는 결과를 초래하므로 발생 가능한 상황에 대해 조심해야 한다.
널값, 옵셔널, 오류를 전달하는 방식이 간단하고 효과적인 대안이다.

### 6.2 널 객체 패턴을 적절히 사용하라

널 객체 패턴을 사용하는 이유는 널값을 반환하는 대신 유효한 값이 반환되어 그 이후에 실행되는 로직에서 널값으로 인해 시스템에 피해가 가지 않도록 하기 위함이다.

오류 처리 이외의 경우에 널 객체 패턴을 사용하면 유용하지만 부적절하게 사용하면 예측을 벗어나는 동작을 하거나 발견하기 어려운 미묘한 버그가 발생할 수 있다.

#### 6.2.1 빈 컬렉션을 반환하면 코드가 개선될 수 있다

``` java
return getClassNames(element).contains("highlighted");
```

getClassNames가 빈 컬렉션을 반환하면 널 여부를 확인할 필요가 없다.
이렇게 하면 호출하는 쪽의 코드는 간단해지고 코드가 예측을 벗어나는 작동을 할 가능성이 매우 낮다.
그러나 좀 더 복잡한 상황에서는 널 객체 패턴을 사용하는 경우 예측을 벗어나는 작동을 할 위험이 커지는 반면 이점은 적어질 수 있다.

```
의견)
이 부분에서는 확실히 널 객체에 대해 오류 처리에 대한 언급이 없으므로
로버트 마틴을 불러서 대화를 시켜보면 정말 재밌을 것 같다는 생각이 든다.
왜냐하면 클린 코드에서 널을 반환하지 말고 널 객체 패턴을 쓰라는 얘기를 엄청 하기 때문이다
```

#### 6.2.2 빈 문자열을 반환하는 것도 때로는 문제가 될 수 있다

이 방식이 적절한지의 여부는 문자열이 어떻게 사용되는지에 달려있다.

어떤 경우에는 문자열이 문자들을 모아 놓은 것에 지나지 않으며, 이 경우 널 대신 빈 문자열을 반환하는 것이 적절할 수 있다.
문자열이 이것을 넘어서는 의미를 지닐 때, 널 대신 빈 문자열을 반환 하는 것이 문제가 될 수 있다.

**문자들의 모음으로서의 문자열**

문자열이 별다른 의미를 갖지 않을 때, 호출하는 쪽에서는 반환된 값이 널인지 빈 문자열인지 구별하는 것이 별로 중요하지 않다.

**ID로서의 문자열**

문자열이 없을 수 있음을 함수를 호출하는 쪽에서 명시적으로 인식하도록 하는 것이 중요하다.

#### 6.2.3 더 복잡한 널 객체는 예측을 벗어날 수 있다

새폰을 사서 박스를 열었더니 폰이 없는 비유.
특히 휴대폰이 품절됐으니 다른 가게에 가보라거나 다른 상품을 권하는 대신에 빈 박스를 판 것이나 다른 없다.
즉, 널 객체 패턴을 사용하는 것은 본질적으로 빈 상자를 파는 것과 같다.
호출하는 쪽에서 빈 박스를 받고 놀라거나 당황해할 가능성이 있다면, 널 객체 패턴을 피하는 것이 좋다. 

재고에서 무작위로 커피 머그잔을 가져오는 함수에서 크기가 0인 커피 머그잔 객체를 생성해서 반환하면 문제가 생긴다.
예를 들어 컨설팅 회사가 거액의 용역비를 받고 커피 머그잔 크기의 분포에 대한 보고서를 작성하다면 부정확한 보고서를 작성하게 될 것이다. 그리고 아무도 이 문제를 알아차리지 못할 수도 있다.

따라서 무작위로 선택할 수 있는 머그잔이 없는 경우에는 널을 반환하는 것이 더 나을 수 있다.

#### 6.2.4 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다

널 객체 전용의 인터페이스나 클래스를 정의할 수 있는데
단순히 무언가를 반환하는 기능보다는 무언가를 수행하는 기능을 가지고 있을 때 널 객체가 필요한 것처럼 보일 수 있다.

널을 표현하는 NullCoffeeMug를 정의하고 내부에는 아무 것도 수행하지 않는 함수들만 존재한다면
NullCoffeeMug라는 타입을 보고 널 객체인지 확인할 수 있다는 점이 그나마 개선짐이지만
호출하는 쪽에서 NullCoffeeMug의 인스턴스인지 확인을 요구하는 것은 어색하고 널을 확인하는 것 보다 더 번거로울 수 있다.

널 객체 패턴은 적절한지 예상을 벗어나는 동작을 하는지 의식적으로 생각해야 한다.
널 안전성과 옵셔널을 사용할 수 있는 방법을 통해 '값이 없음'을 표현할 수 있으므로
널 객체 패턴을 주장하는 건 설득력이 떨어진다.

```
의견)
다시 생각해 보니 로버트 마틴 아저씨는 1960년대 부터 프로그래밍을 해온 아주 오래된 사람이고
최근 언어에서 옵셔널 기능을 가진 언어를 접했다고 하더라도
기존의 널 객체 패턴에 대한 주장은 2000년대 언어 수준에 맞춰서 했던 주장이므로
조금은 이해하는 게 좋을 것 같다는 생각도 든다. 
```

### 6.3 예상치 못한 부수 작용을 피하라

부수 효과(side effect)는 어떤 함수의 호출이 함수 외부에 초래한 상태 변화를 의미한다.
일반적인 유형은 아래와 같다

- 사용자에게 출력 표시
- 파일이나 데이터베이스에 무언가를 저장
- 다른 시스템을 호출하여 네트워크 트래픽 발생
- 캐시 업데이트 혹은 무효화

부수 효과가 예상되고 코드를 호출한 쪽에서도 괜찮다고 하면 상관 없지만
부수 효과가 예상되지 않을 경우 놀라움을 유발하고 버그로 이어질 수 있다.

#### 6.3.1 분명하고 의도적인 부수 효과는 괜찮다

``` java
void displayErrorMessage(String message) {
    canvas.drawText(message, Color.RED);
}
```
displayErrorMessage() 함수는 오류 메시지로 캔버스를 업데이트하는 것을 호출하는 쪽에서 예상할 수 있다.

#### 6.3.2 예기치 않은 부수 효과는 문제가 될 수 있다

``` java
Color getPixel(Int x, Int y) {
    canvas.redraw();
    ...
}
```

픽셀 색상을 읽기 전에 캔버스를 다시 그리는 동작을 수행하는 부수 효과를 일으킨다.

**부수 효과는 비용이 많이 들 수 있다**

getPixel() 함수를 실행할 때 시간이 오래 걸리고 화면 깜빡임이 일어난다면,
대부분 끔찍한 버그로 해석할 수 있는 바람직하지 않은 기능이다.

스크린의 width, height 만큼 픽셀 단위로 돌면서 getPixel() 함수를 호출한다고 하면
픽셀마다 스크린을 다시 그리게 되고 시간이 오래 걸리게 되면 시스템이 멈춘 것으로 인식할 가능성이 높다

**호출한 쪽의 가정을 깨트리기**

captureRedactedScreenshot() 함수의 이름을 통해 canvas.redraw()가 호출하지 않을 것으로 가정하지만
내부에서 getPixel() 함수를 통해 canvas.redraw()를 호출하므로 부수 효과가 일어난다.

**다중 스레드 코드의 버그**

각 스레드에서 getPixel()을 호출한다고 가정했을 때
한 스레드에서 캔버스를 다시 그리는 도중에 
다른 스레드에서 캔버스의 픽셀 데이터 값을 읽는다면 잘못된 값을 수 있다.

#### 6.3.3 해결책: 부수 효과를 피하거나 그 사실을 분명하게 하라

픽셀을 읽기 전에 canvas.redraw()를 호출해야 하는 경우
getPixel() 함수의 이름을 redrawAndGetPixel() 과 같은 이름으로 변경해서 redraw()라는 부수 효과가 발생할 것이라는 걸 분명히 한다.

이렇게 수정하는 건 매우 간단하고, 좋은 이름이 얼마나 중요한지 잘 보여준다.

보통 getter 함수는 부수 효과를 일으키지 않으므로 개발자의 자연스러운 정신 모델에서는 이런 함수들이 부수 효과를 일으키지 않을 것이라고 가정한다.
따라서 부수 효과가 일어난다면 그 함수가 부수 효과가 일어나는지 알 수 있도록 하는 책임이 함수 작성자에게 있다.

부수 효과를 일으키지 않는 것이 가장 좋은 방법이지만 실제로 그렇게 하기가 어려울 수 있으므로 
피할 수 없다면 적절하게 부수 효과가 동반되는 이름을 짓는 것이 효과적인 방법이다.

### 6.4 입력 매개변수를 수정하는 것에 주의하라

#### 6.4.1 입력 매개변수를 수정하면 버그를 초래할 수 있다

호출하는 쪽에서는 함수 매개변수로 객체를 전달하면 객체를 빌려준다고 생각하고 함수로 전달하지만
함수 내에서 매개변수로 전달된 객체를 변경한다면 함수 외부에 영향을 미치기 때문에 부수 효과의 또 다른 예시이기도 하다.

함수는 보통 매개변수의 수정은 일어나지 않을 것이라고 가정하고 반환 값으로 결과를 얻는 것을 상식적으로 생각한다.

#### 6.4.2 해결책: 변경하기 전에 복사하라

입력 매개변수 내의 값을 어쩔 수 없이 변경해야 하는 경우에는 변경 전에 새 자료구조에 복사하는 것이 최상의 방법이다.
값을 복사하면 성능상의 문제가 생길 수 있는데 이런 이유로 입력 매개변수가 변결되어야 한다면 함수 이름과 문서에 이런 일이 발생한다는 점을 분명히 하는 것이 좋다.

### 6.5 오해를 일으키는 함수는 작성하지 말라

함수의 이름을 통해 오해의 소지가 생긴다면 예상을 벗어나는 결과와 버그로 이어지기 쉽다.

#### 6.5.1 중요한 입력이 누락되었을 때 아무것도 하지 않으면 놀랄 수 있다

매개변수가 없어도 호출할 수 있고
매개 변수가 없으면 아무 작업도 수행하지 않는 함수가 있다면
충분히 오해의 소지가 있을 수 있다.

특히 매개변수가 널이 가능한 값을 허용했는데, 정작 널일 경우 아무것도 하지 않으면 문제가 있다.

#### 6.5.2 해결책: 중요한 입력은 필수 항목으로 만들라

어떤 매개변수 없이 함수가 수행하려는 작업을 못 하는 경우 그 매개변수는 해당 함수에 중요할 수 있다.
이런 경우에는 널을 허용하지 않는 것이 더 안전할 수 있다.

예상을 벗어나는 코드 때문에 발생한 버그를 수정하는 데 드는 시간과 노력은
널 여부를 확인하는 문장을 읽는데 드는 시간보다 훨씬 더 크다.
코드를 명확하게 작성하는 것의 이점은 코드를 몇 줄 더 추가하는 비용을 훨씬 더 능가한다.

```
의견)
나중에 가독성을 위한 리팩터링을 진행한다면
버그를 수정하는데 드는 시간과 노력을 줄일 수 있다는 생각을 가지고
코드를 더 명확하게 하는 리팩터링을 하게 될 것 같다.
```

### 6.6 미래를 대비한 열거형 처리

열거형enum에 대한 논쟁

- 형 안전성을 제공하고 함수나 시스템에 유효하지 않은 입력을 방지할 수 있는 훌륭하고 간단한 방법이라는 주장
- 열거형의 특정 값을 처리하기 위한 논리가 코드 전반에 퍼져 있게 되기 때문에 간결한 추상화 계층을 막는다고 주장
  - 어떤 값이 클래스에서만 사용된다면 그 클래스 내에 해당 값에 대한 정보와 동작을 캡슐화한 다음, 이 클래스들이 공통 인터페이스를 구현하도록 하자는 것이 이 주장의 요지

어쨌든 열거형은 쓸 수 밖에 없는데

- 다른 사람의 코드를 사용해야 하는데, 어떤 이유로든 그들이 쓰는 열거형을 써야 함
- 다른 시스템에서 제공하는 결과를 사용하는데, 종종 데이터 형식에서 유일하게 실용적인 옵션일 수 있다.

여기서 열거형을 쓸 때 어떤 부분에서 예측이 벗어나는가?
열거형은 잠재적으로 나중에 더 많은 값이 추가될 수 있기 때문에
이것을 무시하고 코드를 작성해 두면 나중에 예측을 벗어나는 좋지 않은 결과를 초래한다.

#### 6.6.1 미래에 추가될 수 있는 열거값을 암묵적으로 처리하는 것은 문제가 될 수 있다

보통 열거형 내의 값들만 보고 if문으로 처리하는데, 나중에 다른 값이 추가될 경우 문제가 될 수 있다.

#### 6.6.2 해결책: 모든 경우를 처리하는 스위치 문을 사용하라

열거형의 일부 값을 암시적으로 처리하면 새로 추가되는 값이 암묵적으로 처리 되므로 문제가 된다.
모든 열거형의 값을 명시적으로 처리하고, 처리되지 않은 새로운 열거형 값이 추가되는 경우 코드 컴파일이 실패하거나 테스트가 실패하게 한다.
이를 위해서는 모든 경우를 다 처리하는 스위치문을 사용한다.

열거형의 모든 값을 테스트 하고 명시적으로 열거형에서 처리하지 못하는값이 생긴다면 비검사 예외를 발생시킨다. 

> 컴파일타임 안전성
모든 열것값을 완전히 처리하지 않은 스위치 문에 대해서 경고를 생성할 수 있다.

#### 6.6.3 기본 케이스를 주의하라

열거형을 처리하는 스위치 문에 기본(default) 케이스를 추가하면 향후 열거형의 값이 암시적으로 처리될 수 있으며 이 역시 잠재적으로 예기치 않은 문제와 버그가 발생할 수 있다.

기본 케이스문은 새로 추가한 열것값에 대해 항상 원하지 않는 값을 반환한다.
명시적으로 처리되지 않은 예측은 안전하지 않은 비즈니스 전략으로 간주한다.

**기본 케이스에서 예외 발생** 

열것값이 처리되지 않았음을 나타내는 예외를 발생하는 것으로
기본 케이스에서 항상 예외가 발생하도록 한다.
이건 미묘한 방식으로 오류 발생을 더 쉽게 만들 수 있다.

컴파일러가 처리되지 않은 열것값에 대한 경고를 여전히 출력하도록 하려면
스위치 문이 끝나고 예외를 던지는 게 낫다.

#### 6.6.4 주의 사항: 다른 프로젝트의 열거형에 의존

다른 프로젝트에서 미리 알려주지 않고 새로운 열거값을 추가할 가능성이 있고 이로 인해 코드가 동작하지 안을 수 있다면
새로운 값을 다루는 데 있어 허용 범위가 넓어지게 된다. 이에 관해서는 스스로 판단해야 한다.

### 6.7 이 모든 것을 테스트로 해결할 수는 없는가?

코드를 작성하는 시점의 테스트 코드는 제어가 가능하다.
하지만 예상을 벗어나는 코드를 피하는 것은 기술적 정확성 때문은 아니다.
내가 작성한 코드를 다른 개발자가 쓸 때가 있으므로 그 코드가 올바르게 작동하도록 하기 위한 작업으로 이해해야 한다.

```
의견)
테스트에 대한 저자의 주장이 매우 흥미롭게 다가온다.
테스트 코드를 빡세게 짜면 이런 문제를 해결할 수 있다는 테스트 코드 빠돌이들에게 이상주의적인 주장이라고 하다니 ㅋㅋㅋ
특히 목 객체에 대한 테스트 프로그래밍에서 자신이 생각하는 대로 프로그래밍한다는 점에서 본인의 경험담인지 아니면 많은 개발자들이 그래온걸 얘기하는 건지 정확하지는 않으나, 많이 동의한다.
나 역시도 내가 생각한 케이스에 대한 테스트 코드를 작성할 뿐 그 외 예외 케이스에 대한 건 특별히 작성하지 않기 때문에 뭔가 찔리는 느낌도 많이 들었다.
```

테스트는 중요하지만, 예상을 벗어나는 코드에 숨어 있는 오류를 테스트만으로 방지하기는 어렵다.

### 요약

- The code we write will often be depended on by code that other engineers write.
  - If other engineers misinterpret what our code does, or fail to spot special scenarios they need to handle, then it’s likely that code built on top of ours will be buggy.
  - One of the best ways to avoid causing surprises for callers of a piece of code is to ensure that important details are in the unmistakably obvious part of the code’s contract.
- Another source of surprises can occur if we make brittle assumptions about code that we depend on.
  - An example of this is failing to anticipate new values being added to an enum.
  - It’s important to ensure that either our code stops compiling or a test fails if code that we depend on breaks one of our assumptions.
- Testing alone does not make up for code that does surprising things: if another engineer misinterprets our code, then they may also misinterpret what scenarios they need to test. 