## Part 1 이론

좋은 코드를 작성하기 위해서는 당면한 상황에 합리적인 판단력을 적용해야 하고,
어떤 특정한 행동 방식의 결과(그것이 좋든 나쁘든)가 어떻게 될지 주의 깊게 생각해야 한다.

- 코드를 작성할 때 실제로 달성하고자 하는 것은 무엇인가?
- 그 목표에 도달하기 위해 도움이 되는 높은 수준에서의 고려 사항은 무엇인가?

## 1장 코드 품질

<pre>
논의 내용)
소프트웨어 공학에 대해 잘 알고 있거나 모르고 있더라도 고품질 코드를 위해 어떤 것들을 하면 좋은지에 대해 한번쯤은 들어본 용어가 있을 것이라고 생각한다.
그런 것들이 정말 왜 필요한지 생각을 해보는 건 좋은 기회이자 시간이라고 본다. 
오히려 <b>고품질 코드를 위해 못하고 있는 부분이 뭔지 하나 쯤 얘기</b>해 보면 좋을 것 같다. 

예를 들면 테스트 코드 작성이라던지, 모듈화를 위한 것이라던지 하는 것들.

나의 경우 계속해서 드는 생각은 이런 고품질 코드를 위한 활동에 대해 모르는 사람은 없지만 
제한된 시간, 제한된 리소스, 소프트웨어에 대한 무지로 인해
고품질 소프트웨어를 만들려고 하는 분위기 보통은 개발 문화가 잘 만들어지지 않고서는 달성할 수 없다고 생각한다.
</pre>

고품질 코드는 일반적으로 좀 더 신뢰할 수 있고, 유지보수가 쉬우며, 버그가 적은 소프트웨어를 생산한다.
코드 품질을 높이는 것에 관한 많은 원칙들은 소프트웨어가 처음에 만들어지는 방식을 보장하는 것뿐만 아니라,
이후에 요구 사항이 진화하고 새로운 상황이 등장하더라도 그 방식을 계속 유지할 수 있도록 하는 것에 관심을 둔다.

좋은 소프트웨어는 엔지니어들이 코드를 작성할 때 내리는 작고 보잘것없는 일상적인 결정들이 모여서 이루어진다.

```
의견)
코드 품질이 중요하다고 생각하는 이유를 간략히 정리한 것인데
좋은 소프트웨어를 만들기 위한 노력이라고 볼 수 있을 것 같다.
```

### 1.1 코드는 어떻게 소프트웨어가 되는가

소프트웨어 개발 및 배포 프로세스에 대한 간략한 용어 정리

- code base: repository, git
- submitting code: 'committing code' or 'merging a pull reqeust'
- code review: 원고 교정과 비슷함
- pre-submit check: 'pre-merge hook' or 'pre-merge check' or 'pre-commit check'. 테스트가 실패하거나 코드가 컴파일되지 않을 경우 변경 사항이 코드베이스에 병합되지 않도록 차단한다.
- release: 소프트웨어는 코드베이스의 스냅숏을 기반으로 빌드된다. cutting release(배포 브랜치 만들기)
- production: 소프트웨어가 서버나 시스템에 배포되서 실제 서비스 되는 환경

### 1.2 코드 품질의 목표

때때로 어떤 코드를 접하고 '헐~' 이라고 하거나 '와, 이건 임시로 땜빵한 코드네' 라고 생각할 수 있다.
또 어떤 때는 우연히 본 코드에서 '이건 훌륭한 코드네'라고 감탄할 수도 있다.
코드를 접할 때 이런 반응을 보이는 이유가 항상 분명한 것은 아니며, 때로는 근거 없는 직감일 수도 있다.

```
의견)
너무 맞는 말이기도 하고 재미있어서 한참을 웃었다.
실질적인 코드의 품질은 파악하기 어렵고, 주관적일 가능성이 높다는 걸 비꼬는 것이기도 하다.
```

코드를 통해 정말로 달성하려는 것이 무엇인지 생각해 보는 것이 유용하다.
이러한 것을 달성하는 데 도움이 되면 그 코드는 높은 품질의 코드이고, 방해된다면 낮은 품질의 코드이다.

#### 1.2.1 코드는 작동해야 한다

코드의 첫 번째 목표는 그것이 애초 작성된 목적대로 동작해야 한다는 것이다.
코드는 우리가 해결하려고 하는 문제를 실제로 해결해야 한다.

#### 1.2.2 코드는 작동이 멈추면 안된다

코드는 고립된 환경에서 홀로 실행되는 것이 아니고 주변 상황이 바뀌면서 동작이 멈출 수 있다.

- 의존성 문제로 의존 코드가 수정되고 변경될 때
- 기존 코드에 새로운 기능이 필요해서 코드를 수정할 때
- 해결하려고 하는 문제는 시간이 지나면서 변경되기 때문에 (소비자 선호, 비즈니스 요구, 고려해야 할 기술)

당장 돌아가는 코드를 만들기는 쉽지만,
변화하는 환경과 요구 사항에도 불구하고 계속 작동하는 코드를 만드는 것은 훨씬 더 어렵다.
코드가 계속 작동하도록 보장하는 것은 소프트웨어 엔지니어가 직면하는 큰 과제 중 하나이다.

#### 1.2.3 코드는 변경된 요구 사항에 적응할 수 있어야 한다

- 비즈니스 환경이 변한다
- 사용자 선호가 변한다
- 가정이 더 이상 유효하지 않다
- 새로운 기능이 계속 추가된다

요구사항이 변할 것이라는 사실을 알지만, 어떻게 변할 것인지는 정확히 알 수 없다. 
하지만 어떻게 변할지 정확히 알지 못한다고 해서 변한다는 사실 자체를 완전히 무시해야 하는 건 아니다.

완벽할 설계와 변화하는 요구사항을 고려하여 길게 시간을 써서 개발 기간이 늘어나는 경우
or
현재 요구사항만을 충족하는 코드를 작성하고 변화는 무시한다, 3개월 만에 출시는 가능하지만, 새로운 기능과 변화하는 요구사항을 수용하지 못해 새로 개발한다

이 둘 중에 중간 어딘가에서 접근법을 찾아야 하고 어느 지점이 최적인지는 아무도 모른다.
그것은 진행하고 있는 프로젝트와 조직 문화에 달려 있다.

```
의견)
어떤 조직 문화에서 소프트웨어가 개발되는 가는 정말 중요한 문제라고 생각한다.
10 페이지 정도 밖에 안 읽었는데 벌써 감동의 눈물이 흐르는 중
```

#### 1.2.4 코드는 이미 존재하는 기능을 중복 구현해서는 안 된다

하위 문제 중 다른 사람이 해결한 것이라면 재사용을 하면 되는데, 좋은 이유가 몇 가지 있다.

- 시간과 노력을 절약한다.
- 버그 가능성을 줄여준다.
- 기존 전문지식을 활용한다.
- 코드가 이해하기 쉽다.

다른 관점에서
자신이 하위 문제를 해결하기 위해 이미 코드를 작성했다면, 다른 개발자를 위해 쉽게 재사용할 수 있는 방식으로 코드를 구성해야 한다.

### 1.3 코드 품질의 핵심 요소

(과장된 용어로) 코드 품질의 6가지 핵심 요소

#### 1.3.1 코드는 읽기 쉬워야 한다

코드를 작성하고 난 후 다른 개발자가 그 코드를 읽고 이해해야 하는 상황이 반드시 온다.
코드의 가독성이 떨어진다면 다른 개발자가 그 코드를 이해하는 데 많은 시간을 들여야 한다.

코드가 무엇을 하는지 개발자가 이해하지 못하면, 소프트웨어 전체가 제대로 자동하는 것은 거의 불가능에 가깝다.

초콜릿 브라우니 만들기 레시피와 마찬가지로 코드도 읽을 수 있어야 한다.

#### 1.3.2 코드는 예측 가능해야 한다

Mental model: 전화를 예로 들면 누군가와 통화를 할 때 우리 두뇌 안에 저장된 전화에 대한 인식이 통화한 번호로 연결됐다고 생각함.

코드도 마찬가지로 이름, 데이터 유형, 일반적인 관행과 같은 단서로
코드가 입력값으로 무엇을 예상하는지, 코드가 무슨 일을 하는지, 무엇을 반환하는지에 대한 mental model을 구축한다.
이 모델과 어긋나는 어떤 일이 코드에서 일어나면, 버그가 아무도 모르게 코드로 유입되는 일이 많이 일어난다.

코드가 아무리 좋은 의도를 가지고 있더라도 예상을 벗어난 동작을 수행하는 위험이 있을 수 있다.
코드가 예상을 벗어나는 일을 수행하지 않는지 주의 깊게 살펴야 한다.

#### 1.3.3 코드를 오용하기 어렵게 만들라

코드의 오용
자신이 작성한 코드가 호출된 데는 이유가 있는데,
그 코드가 잘못 사용되면 수행되지 않거나 이상하게 동작하지만 눈에 띄지 않을 수 있다.

코드를 오용하기 어렵거나 불가능하게 만들면 코드가 계속해서 잘 작동할 가능성을 극대화할 수 있다.

#### 1.3.4 코드를 모듈화하라

모듈화된 시스템의 주요 특징은 인터페이스가 잘 정의되어 서로 다른 구성 요소 간 상호작용하는 지점이 최소화된다는 점이다.
코드를 외부에 의존하지 않고 실행할 수 있는 모듈로 나누면 변화하는 요구사항에 더 쉽게 적응할 수 있는 코드를 작성하는 데 도움이 된다.

모듈화된 시스템은 이해하기 쉽고 추론하기 쉬운데, 기능이 관리 가능한 단위로 나누어지고 기능 단위 간 상호작용이 잘 정의되고 문서화되기 때문이다.
모듈화가 잘 되어 있으면 처음에 작동이 시작되고 그 후에도 계속해서 잘 작동할 가능성이 커진다. 

#### 1.3.5 코드를 재사용할 수 있고 일반화하도록 하라

- 재사용성reusability: 어떤 문제를 해결하기 위한 무언가가 여러 가지 다른 상황에서도 사용될 수 있다.
- 일반화성generalizability: 개념은 유사하지만 서로 미묘하게 다른 문제들을 해결할 수 있음을 의미.

코드를 만들어 내는 데는 시간과 노력이 필요하고, 이후에 유지보수에 지속적인 시간과 노력이 들어간다.
코드에는 버그가 포함될 수 있고, 코드를 더 많이 작성할수록 더 많은 버그가 생긴다.
코드베이스에서 코드 라인이 적을수록 좋다.
코드를 많이 작성한 것에 대한 대가가 아니라 문제를 해결한 것에 대한 대가이다. 코드는 문제 해결을 위한 수단이다.

```
의견)
대가는 문제를 해결한 것으로 받는다. 코드는 문제 해결을 위한 수단이다.
너무 좋은 말이다.
코딩을 잘 하는 것으로 실력을 보여주려고 하는 개발자에게 좋은 일침을 줄 수 있을 듯. 
``` 

노력을 덜 기울이면서 문제를 해결하고, 버그로 문제를 일으킬 가능성을 줄일 수 있다면, 그것은 대단한 것이다.

코드의 재사용과 일반화는 하나 이상의 상황에서 사용할 수 있고 여러가지 문제를 해결할 수 있다.
이런 코드는 시간과 노력을 절약해주고 신뢰할 수 있는데, 이미 서비스 환경에서 시도되고 테스트된 논리를 재사용 하기 때문이다.

#### 1.3.6 테스트가 용이한 코드를 작성하고 제대로 테스트하라

- 버그나 제대로 동작하지 않는 기능을 갖는 코드가 코드베이스에 병합되지 않도록 방지
- 버그나 제대로 동작하지 않는 기능을 갖는 코드가 배포되지 않도록 막고 서비스 환경에서 실행되지 않도록 보장

테스트는 코드가 동작하고, 멈추지 않고 계속 잘 실행하도록 보장하기 위해 필수적인 부분이다.

테스트가 중요한 진짜 이유

- 소프트웨어 시스템과 코드베이스는 너무 크고 복잡해 한 사람이 모든 세부 사항을 알 수 없다.
- (매우 똑똑한 개발자라 해도) 사람은 실수를 하는 존재다.

테스트와 테스트 용이성은 서로 관련은 있지만 고려하는 사항이 다르다.

- 테스트test: 코드 혹은 소프트웨어 전체를 수동 혹은 자동으로 테스트
  - 단위 테스트unit test:
  - 통합 테스트integration test
  - 종단간 테스트end-to-end  
- 테스트 용이성testability: 테스트 대상이 되는 '실제'코드가 얼마나 테스트하기 적합한지를 나타낸다. 테스트 용이성은 모듈화와 관련이 깊다.

현재 코드의 테스트 용이성을 확인하기 위해 코드를 작성하면서 '어떻게 테스트할 것인가?'를 계속 자문하는 것이 좋다.
코드를 다 작성하고 나서 테스트에 대해 생각해서는 안 된다.

### 1.4 고품질 코드 작성은 일정을 지연시키는가?

'서두르지 않으면 더 빠르다'라는 말은 고품질 코드를 작성하는 것이 왜 시간을 절약하는 길인지를 한 문장으로 잘 요약해준다.
서두른다고 빨리할 수 있다고 착각하지 말자.

### 요약

- To create good software, we need to write high-quality code.
- Before code becomes software running in the wild, it usually has to pass several stages of checks and tests (sometimes manual, sometimes automatic).
- These checks help prevent buggy and broken functionality reaching users, or business critical systems.
- It’s good to consider testing at every stage of writing code; it shouldn’t be considered as an afterthought.
- It might seem like writing high-quality code slows us down initially, but it often speeds up development times in the mid to long term. 