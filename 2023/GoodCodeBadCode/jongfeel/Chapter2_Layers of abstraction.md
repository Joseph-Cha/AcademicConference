## 2장 추상화 계층

코드 작성의 목적은 문제 해결이다.
문제 해결을 위해 하위 문제를 나누고 해결하는 코드를 어떻게 구성하는가가 중요하다.
코드를 잘 구성한다는 것은 간결한 추상화 계층layers of abstraction을 만드는 것으로 귀결된다.

<pre>
논의내용)
추상화를 통해 문제를 해결하는 것은 책의 설명대로 코드의 계층을 어떻게 나눌 것인지에 대한 방법으로 이해해 볼 수 있다.

추상화가 잘 되어 있는 코드는 읽기 쉬운 코드일 가능성이 높은데
<b>어떤 추상화 레벨을 만들어서 그런 코드를 만들어 본 적이 있는지 혹은 그렇게 만들어야 겠다는 시도를 했는지</b> 얘기해 보면 좋을 것 같다.

책의 인터페이스 예시 처럼 구현에 의존하지 않고 인터페이스에 의존하는 코드를 만들어 본 적이 있고
그렇게 했을 때 조금 더 객체가 해야하는 혹은 할 수 있는 일에 집중해서 구현할 수 있다는 느낌을 많이 받아 본 적이 있다.  
</pre>

### 2.1 널값 및 의사코드 규약

많은 프로그래밍 언어에는 값(또는 참조/포인터)이 없다는 개념을 가지고 있다.
이 개념을 표현하기 위해 널null값을 사용한다.

- '값이 없다' 또는 부재한다'는 이 개념은 유용하다
- 항상 명백한 것은 아니어서 문제가 발생하고, null 인지 확인하는 것을 자주 잊어버리기 때문에 exception이 발생한다.

널 안전성null safety은 최근 많은 언어에서 지원해 주고 있고
책의 의사코드는 null safety가 있다고 가정한다.

### 2.2 왜 추상화 계층을 만드는가?

하나의 문제가 있을 때 이 문제와 하위 문제에 대한 해결책이 층을 형성하고 있고
이미 해결했고 알 필요도 없을 정도의 하위 문제는 추상화가 되어 있다.

서버에 메시지를 보내는 코드는 아래 코드이고 네 가지 개념만 다루면 된다.

```
HttpConnection connection = HttpConnection.connect("http://example.com/server");
connection.send("Hello server");
connection.close(); 
```

서버의 URL, 연결, 메시지 문자열 보내기, 연결 닫기 

어떤 문제를 하위 문제로 계속 나눠서 내려가면서 추상화 계층을 만든다면,
같은 층위 내에서는 쉽게 이해할 수 있는 몇 개의 개념만을 다루기 때문에 개별 코드는 특별히 복잡해 보이지 않는다.

소프트웨어 엔지니어로서 문제를 해결할 때 이것이 목표가 되어야 한다.

### 2.2.1 추상화 계층 및 코드 품질의 핵심 요소

깨끗하고 뚜렷한 추상화 계층을 구축하면 코드 품질의 네 가지 핵심 요소를 달성할 수 있다.

**가독성**

코드의 모든 세부 사항을 이해하는 것은 불가능하지만 몇 가지 높은 계층의 추상화를 이해하고 사용하기는 상당히 쉽다.

**모듈화**

추상화 계층이 하위 문제에 대한 해결책을 깔끔하게 나누고 구현 세부 사항이 외부로 노출되지 않도록 보장할 때,
다른 계층이나 코드의 일부에 영향을 미치지 않고 계층 내에서만 구현을 변경하기가 매우 쉬워진다.

**재사용성 및 일반화성**

추상화 계층의 하위 문제에 대한 해결책은 재사용하가 쉬워진다. 
문제가 적절하게 추상적인 하위 문제로 세분화된다면, 해결책은 여러 가지 다른 상황에서 유용하게 일반화될 가능성이 크다.

**테스트 용이성**

신뢰할 수 있는 코드를 작성하고자 한다면, 각 하위 문제에 대한 해결책이 견고하고 제대로 작동하는지 확인해야 한다.

### 2.3 코드의 계층

코드를 서로 다른 단위로 분할하여 단위 간의 의존 관계를 보여주는 의존성 그래프를 생성해서 보여준다.

- 함수
- 클래스 (및 구조체나 믹스인과 같이 클래스와 비슷한 요소도 가능)
- 인터페이스 (또는 이와 동일한 요소)
- 패키지, 네임스페이스, 모듈

#### 2.3.1 API 및 구현 세부 사항

코드를 작성할 때 고려해야 할 측면 두 가지

- 코드를 호출할 때 볼 수 있는 내용
  - 퍼블릭 클래스, 인터페이스 및 함수(메서드)
  - 이름, 입력 매개변수 및 반환 유형이 표현하고자 하는 개념
  - 코드 호출 시 코드를 올바르게 사용하기 위해 알아야 하는 추가 정보(예: 호출 순서)
- 코드를 호출할 때 볼 수 없는 내용: 구현 세부 사항

API는 호출하는 쪽에 공개할 개념만 정의하고, 그 외는 구현 세부 사항이므로
코드를 API 관점에서 생각하면 추상화 계층을 명확하게 만드는 데 도움이 된다.

#### 2.3.2 함수

어떤 로직을 새로운 함수로 구현하면 대부분 유익하다.
각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적이다.

함수가 하는 일을 아래와 같이 제한하면 이해하기 쉽고 단순한 문장으로 표현되는 함수를 작성하기 위한 좋은 전략이 될 수 있다.

- 단일 업무 수행
- 잘 명명된 다른 함수를 호출해서 더 복잡한 동작 구성

함수를 작성하면 작성된 코드를 문장으로 만들어 본다.
문장을 만들기 어렵거나 너무 어색하면 함수가 너무 긴 것이므로 더 작은 함수로 나누는 것이 유익하다.

코드를 마구 작성하다 보면 너무 길어서 읽을 수 없는 함수가 되기 쉽다.
따라서 코드 작성을 일단 마치고 코드 검토를 요청하기 전에 자신이 작성한 코드를 비판적으로 다시 한번 살펴보는 것이 좋다.

```
의견)
코드 commit 하기 전에 자신의 코드를 한번 둘러보는 건 좋은 방법이고
나도 그런 방법으로 검토하면서 리팩터링도 진행하고 또 다른 방식으로 코드를 작성하거나 나누는 작업을 추가하기도 한다.
```

#### 2.3.3 클래스

단일 클래스의 이상적인 크기에 대한 논의

- 줄 수number of lines: 한 클래스는 300줄을 넘지 않아야 한다
  - 300줄 보다 긴 클래스는 분리해야 한다는 주장은 많은 경우에 사실이다.
- 응집력cohesion: 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도로, 좋은 클래스는 매우 응집력이 강하다.
  - 순차적 응집력: 한 요소의 출력이 다른 요소에 대한 입력으로 필요할 때 발생
  - 기능적 응집력: 몇 가지 요소들이 모여서 하나의 일을 성취하는데 기여할 때 발생
- 관심사의 분리separation of concerns: 시스템이 각각 별개의 문제(또는 관심사)를 다루는 개별 구성 요소로 분리되어야 한다고 주장하는 설계 원칙, TV와 게임기의 관계

응집력과 관심사의 분리에 대해 생각할 때는 서로 관련된 여러 가지 사항을 하나의 사항으로 간주하는 것을 어느 수준에서 해야 유용할지 결정해야 한다.

'클래스는 응집력이 있어야 하고 한 가지 일에만 관심을 가져야 한다'와 같은 말에 동의하지 않는 개발자는 없다.
하지만 많은 개발자가 여전히 너무 큰 클래스를 작성한다.
기존 코드를 수정할 때나 완전히 새로운 코드를 작성할 때 클래스가 너무 커지는 것은 아닌지 주의해야 한다.

이런 클래스의 경험칙은 높은 품질의 코드를 작성하기 위해 존재하지만, 근본적으로 성취하려고 하는 것에 대해서도 신중하게 생각할 필요가 있다.

- 코드 가독성: 단일 클래스에 담겨 있는 개념이 많을수록 해당 클래스의 가독성은 저하된다.
- 코드 모듈화: 클래스 및 인터페이스의 사용은 코드 모듈화를 위한 좋은 방법 중 하나다.
- 코드 재사용성 및 일반화: 두 하위 문제에 대한 해결책 중 하나를 다른 누군가가 해결해야 하는 상황이 올수 있다.
- 테스트 용이성 및 적절한 테스트: 로직이 여러 클래스로 나누어지면 각 부분을 적절하게 테스트하기가 훨씬 쉬워진다.

큰 클래스가 책의 예제에서 제시되는데 다음과 같은 경우를  근거로 저품질 코드라는 결론을 내릴 수 있다.

- 코드를 읽을 수 없다: 여러 개념이 하위 문제를 해결하는데 필요한지 파악하는데 시간이 걸린다.
- 코드가 특별히 모듈화되어 있지 않다: 따라서 코드를 재구성하거나 수정하는 것이 어렵다.
- 코드를 재사용할 수 없다: 다른 문제를 해결할 때 여기서 해결된 하위 문제와 동일한 하위 문제를 해결해야 할 수도 있다.
- 코드를 일반화할 수 없다: 입력이 변경됨에 따라 (일반 텍스트 혹은 html 텍스트) 추가 작업이 필요하다. 모듈화가 되어 있다면대체 가능한 요소로 쉽게 구현 가능할 수 있다.
- 코드를 제대로 테스트하기 어렵다: 해결하려는 하위 문제들은 실제로 복잡하다. 그래서 제대로 테스트하기 어렵다. 

**코드 개선 방법**

생성자의 매개변수를 통해 하위 문제를 해결한다. 의존성 주입dependency injection 기법.
하위 문제에 대한 클래스를 분리했고, 각 클래스마다 개념만 파악하면 되므로 코드의 가독성이 좋아짐

개선된 클래스의 추가 이점

- 코드가 좀 더 모듈화되고 재구성할 수 있게 됨
- 코드의 재사용성이 좀 더 높아짐
- 코드의 테스트 용이성이 더 높아짐

클래스 구조를 설계할 때 코드 품질 네 가지 핵심 요소를 충족하는지 신중하게 생각하면 좋다.
코드를 적절한 크기의 클래스로 세분화하는 것은 추상화 계층을 잘 만들기 위한 가장 효과적인 도구이기 때문에
이를 위한 시간과 노력을 들일 만한 가치가 충분히 있다.

#### 2.3.4 인터페이스

계층 사이를 뚜렷이 구분하고 구현 세부 사항이 계층 사이에 유출되지 않도록 하기 위해
어떤 함수를 외부로 노출할 것인지를 인터페이스를 통해 결정한다.

하나의 추상화 계층에 대해 두 가지 이상의 다른 방식으로 구현을 하거나 다르게 구현할 것으로 예상되는 경우 인터페이스를 정의하는 것이 좋다.

추상화 계층을 깔끔하게 구현하는 코드를 만드는 데 있어 인터페이스는 매우 유용한 도구다.
주어진 하위 문제에 대해 둘 이상의 서로 다른 구체적인 구현이 가능하고 이들 구현 클래스 사이에 전환이 필요할 때는 추상화 계층을 나타내는 인터페이스를 정의하는 것이 가장 좋다.
이를 통해 코드를 더욱 모듈화할 수 있고 재설정도 훨씬 쉽게 할 수 있다.

**모든 것을 위한 인터페이스?**

추상화 계층에 한 가지 구현만 있고 향후에 다른 구현을 추가할 계획이 없어도
인터페이스를 통해 추상화 계층을 표현해야 하는가는 주관적이고 팀에서 결정할 사안이다.
몇몇 소프트웨어 공학 철학은 이 상황에서도 여전히 인터페이스를 사용할 것을 권고한다.

향후 다르게 구현할 필요가 있을지 현재는 알 수 없어도 이 방식은 몇 가지 장점이 있다.

- 퍼블릭 API를 매우 명확하게 보여준다: 사용해야 하는 기능과 사용하지 말아야 하는 기능에 대해 혼동할 일이 없다.
- 한 가지 구현만 필요하다고 잘못 추측한 것일 수 있다: 향후 몇 달 후에 추가 구현이 필요 없다는 가정이 잘못된 것으로 판명될 수 있다.
- 테스트를 쉽게 할 수 있다: 구현 클래스가 복잡하거나 네트워크에 의존한다면 mock이나 fake 객체로 대체해야 하는데, 이렇게 하려면 프로그래밍 언어에 따라 인터페이스를 정의해야 할 수 있다. 
- 같은 클래스로 두 가지 하위 문제를 해결할 수 있다: 한 클래스가 두 개 이상의 서로 다른 추상화 계층에 구현을 제공할 수도 있다.

다음과 같은 단점 역시 존재한다

- 더 많은 작업이 필요하다: 인터페이스 정의에는 코드를 더 작성해야 하고 새 파일도 추가해야 할 수 있다.
- 코드가 복잡해질 수 있다: 다른 개발자가 코드를 이해하려고 할 때 논리 탐색에 어려움이 있을 수 있다.

깨끗하고 뚜렷한 추상화 계층을 만드는데 집중하는 것은 여전히 중요하고
인터페이스를 정의하지 않더라도 클래스에서 어떤 함수를 퍼블릭으로 노출할지 매우 신중하게 생각하고 구현 세부 사항이 유출되지 않도록 해야 한다.

#### 2.3.5 층이 너무 얇아질 때

코드를 별개의 계층으로 세분화하면 장점이 많지만 다음과 같은 추가 비용이 발생한다.

- 클래스를 정의하거나 의존성을 새 파일로 임포트하려고 반복적으로 사용하는 코드boilerplate code로 인해 코드의 양이 늘어난다.
- 로직의 이해를 위해 파일이나 클래스를 따라갈 때 더 많은 노력이 필요하다.
- 인터페이스 뒤에 계층을 숨기게 되면 어떤 상황에서 어떤 구현이 사용되는지 파악하는 데 더 많은 노력이 필요하다. 이로 인해 로직을 이해하거나 디버깅하는 것이 더 어려워질 수 있다.

장점에 비해 비용은 상대적으로 낮지만, 비용이 이익보다 더 큰 시점이 올 수 있으므로 상식에 맞게 적용하는 것이 좋다.

코드 계층의 규모를 올바르게 결정하는 것은 중요하다.
추상화 계층이 없으면 전혀 관리할 수 없는 코드가 된다.
계층을 너무 얇게 만들면 단일 계층으로 만들어도 될 것을 둘로 분해한 것이고 불필요한 복잡성을 초래할 수 있다.
보통은 많은 일을 하는 계층은 적은 일을 하는 계층 보다는 문제가 있으므로, 계층을 여러개로 나누는 것이 낫다.

수십 년의 경험을 가진 개발자라 할지라도 추상화 계층을 올바르게 만들기 위해 설계와 재작업을 여러 번 반복해야 할 수도 있다.

### 2.4 마이크로서비스는 어떤가?

마이크로서비스 아키텍처에서는 개별 문제에 대한 해결책이 독립적으로 실행되는 서비스로 배포된다.

마이크로서비스는 일반적으로 간결한 추상화 계층을 제공하지만, 크기와 범위를 기준으로 나누기 때문에 적절한 추상화 계층을 고려하는 것이 유용하다.

마이크로서비스는 시스템을 분리하여 보다 모듈화할 수 있는 매우 좋은 방법이지만
서비스를 구현하기 위해 여러 하위 문제들을 해결해야 한다는 사실은 바뀌지 않는다.

### 요약

- Breaking code into clean and distinct layers of abstraction makes it more readable, modular, reusable, generalizable, and testable.
- We can use functions, classes, and interfaces (as well as other language-specific features) to break our code into layers of abstraction.
- Deciding how to break code into layers of abstraction requires using our judgement and knowledge about the problem we’re solving.
- The problems that come from having layers that are too thick are usually worse than the problems that come from having layers that are too thin. If we’re unsure, it can often be best to err on the side of making layers too thin. 