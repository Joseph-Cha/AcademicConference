# Ch04. 오류


## 중요 문장

1. 오류는 불가피 하다
2. 오류가 발생하더라도 사용자는 알아채지 못하도록 적절하게 처리한다면 작동을 계속할 수 있는 합리적인 방법이 있다.
3. 일반적으로 시스템 외부의 무언가에 의해 야기되는 오류에 대해서는 대부분 시스템 전체가 표나지 않고 적절하게 처리하기 위해 노력해야 한다.
4. 오류를 복구할 수 있는 방법이 없다면, 유일하게 코드가 할 수 있는 합리적인 방법은 피해를 최소화하고 개발자가 문제를 발견하고 해결할 가능성을 최대화하는 것이다.
5. 간결한 추상화 계층을 만들고자 한다면 일반적으로 코드의 잠재적 호출자에 대한 가정을 가능한 한 하지 않는 것이 좋다.
6. 요란한 실패는 간단히 말하자면 오류가 발생하는데도 불구하고 아무도 모르는 상황을 막고자 하는 것이다.
7. 오류를 전달하는 대신 기록만 하면 오류가 숨겨져 문제가 발생할 수있다
8. 매직값은 코드 계약의 명백한 부분을 통해 호출하는 쪽에 알릴 수 없어서 예상을 벗어나는 결과를 가져올수도있고버그로이어질수있다 … 이 장에서 기억해야 할 중요한 점은 매직값은 오 류를 알리는 좋은 방법이 아니라는 것이다.

## 내 생각

- 오류는 불가피 하다. 오류를 굳이 나누자면 예상된 것과 예상하지 못한 것으로 나눌 수 있다 예상된 것은 테스트 코드 혹은 수동 QA로  어찌되었든 간에 인수조건으로써 동작이 확인되고 재현되어야 한다. 우리가 신경쓸 것은 예상하지 못한 오류 이다. 이런 오류들은 책에서 나온 대로 빠르게 실패하고, 빠르게 인지할 수 있어야 한다 예상하지 못한 오류가 발생할 때는 빠르게 원인을 파악하고 해결한 후에, 예상된 케이스의 하나로써 추가하고 관리해야 한다.
- 기본적으로 장애 대응을 위한 failover, switchover 를 고려하여 미리 가이드를 만들어두는 것은 필요하다고 생각한다 오류를 빠르게 인지하는 것도 중요하지만, 피해를 최소화 하기 위해서 장애 상황 때 신속하게 처리하는 것도 중요하기 때문이다
- 오류는 빠르게 실패하는 것을 인지도 빠르게 하고, 이후 프로세스를 더이상 진행하지 못하게 막는 것이 있는 반면에, 오류발생과 별개로, 멈추지 않고 계속 진행 되어야 하는 경우도 있다. 데이터베이스에 값을 쓰는 작업을 할 때, 여러 테이블에 값을 저장할 경우, 정합성을 맞추기 위해서 트랜잭션 범위를 정해서 all or nothing 으로 처리할 수도 있을 것이고, 정합성보다 빠르게 처리되는게 더 중요하다면, 에러 발생 로그만 찍고, 그 다음 작업을 이어서 할 수있게 하고 후에 에러 로그를 확인해서 후처리 하는 방법도 있을것 같다
- 기본적으로 나는 오류에 대해서는 숨기지 말고 무조건 드러내야 한다고 생각하는 편이다 이를 제대로 처리하지 않는다면 서비스를 사용하는 사용자에게 정말 큰 불편을 줄 수 있다 사용자는 어떤 기능을 쓸 때, 제대로 동작하지 않는 것에 불편을 느끼는데 해당 개발자는 그 사실을 모르거나, 알더라도 매우 늦게 인지할 수 있다 오류는 불가피 하기 때문에, 오류에 대해서는 빠르게 드러나게 하고, 빠르게 장애를 해결할 수 있는 방안을 생각하고 고치는게 중요하다고 생각한다
- 대개의 경우 문제가 숨겨지는 많은 경우는, 그냥 로그만 찍고 끝내는 것이다 로그의 장점은 후에 조회해서 확인해볼 수 있는 점이지만 단점은 개발자가 능동적으로 로그를 확인해야 하니 놓치거나 실수할 가능성이 높다 그렇기 때문에 정리하자면, 서버 입장에서도 예상된 에러는 클라이언트와 소통하여서, 테스트 기간 때 최대한 다양한 케이스를 파악하고 테스트 해보아야 한다
- 매직값 리턴은 예를들어서, 성공은 1, 실패는 0, 오류는 -1, 이런 식으로 내부의 약속을 정하고 리턴값을 분류하는 것이다 이렇게 했을 때 가장 큰 단점은 내부의 이런 약속들을 처음 접하는 사람들은 문서 혹은 사람들에게 물어서 파악을 해야만 한다는 것이다 그리고 코드 가독성 관점에서도 그리좋은 접근은 아닐것 같다 추가적으로 실제로 1, 0, -1 값을 리턴하는 다른 함수가 있을 때, 이것들과 헷갈릴 가능성도 높다

## 질문

1. 파이썬에는 비검사 예외와 검사예외 라는 개념이 없어서, 읽으면서 좀 헷갈렸는데 아래와 같이 이해하면 맞을까요?
    1. 비검사 예외
        1. 에러가 발생할 수 있는 모든 상황을 고려하지 하여서, try-catch로 관리하지 않고, 런타임에서 에러가 발생했을 때, 빠르게 에러가 발생한 것을 인지할 수 있도록 함
        2. 빠르게 에러가 난것을 발견할 수있으나, 서비스를 사용한 사용자는 경우에 따라서, 불편을 겪을 수 있음
    2. 검사 예외
        1. 모든 에러 발생할 수 있는 경우를 고려해서, try-catch 로 명시적으로 에러를 명시해줘서 개발자가 관리할 수 있도록 조정함
            1. 책 예제처럼 일단 로그처리만 하고 넘어갈 수도 있고, 로그처리 후에 후속 처리를 개발자가 주도적으로 선택해서 처리 가능
            2. but, 잘못 처리되었을 때, 에러가 감춰질 위험이 있음 - 로그만 쌓고 끝난다던지..
2. 개인적으로는 어떤 종류의 에러이던지, 개발자가 빠르게 인지하는게 중요하다고 생각합니다. 맥락에 따라 달라질 수는 있긴하지만, **저같은 경우는 에러가 발생하지 않을 명백한 상황이라면,** exception 처리를 하지 않고 그대로 에러가 발생하게 두는것을 선호하는데요(제가 이해한게 맞다면, 비검사 예외 일것 같습니다) 개인의 에러 처리 방식이나, 사례를 공유해주시면 좋을 것 같습니다

ex)

```python
# 에러가 발생하지 않을 명백한 상황 일때, 저는 아래와 같이 처리 합니다


# user_id를 기반으로 유저 정보를 DB에서 조회해서 가져온다
# 검증이 완료된 토큰에서 추출된 user_id 이기 때문에, UserNotFound 에러가 발생할 가능성이 없다
# 그렇기 때문에, Exception을 고려한 코드를 추가작성하는 것은 낭비이고, 코드 작성자의 작성의도를 해칠 수 있다(굳이 exception을 고려할 필요가 없는데, 코드 읽는 사람은 착각할 수 있음)
# 만약에 실제 존재하지 않은 user_id가 전달 되었다면, 비정상적인 케이스이기 떄문에 런타임에서 에러가 발생해서 빠르게 알아채는 것이 맞음
def retrieve_user_detail_info(user_id:int) -> UserInfo:
    user = User.objects.get(user_id=user_id)  
    return UserInfo(user=user)


def main(access_token: JWT):
    # access_token은 토큰 검증이 완료된 상태로 넘어온 것을 가정함
    user_id = access_token.auth.user_id
    return retrieve_user_detail_info(user_id)
```


```python
# 에러가 발생하지 않을 명백한 상황 일때, 저는 아래와 같이 처리하는 것은 자제하는 편입니다
# 아래 두 예제는 에러가 발생할 수도 있는게 명백한 상황에서 사용될 방법이라 생각 됩니다


# case: 1
     # user가 없으면, UserNotFoundError 에러를 raise 하는데,
     # 이를 캐치해서, 에러 로그를 남기고 다시 raise 한다
     # 에러로그를 남겨야할 때 이런 패턴을 사용할 수 있긴하다
     # raise 를 해주지 않으면 에러가 숨겨질 가능성이 높다
     # 에러를 캐치한다음에, 후속 작업이 필요한 경우라면 이런 패턴이 유용할 수 있으나, 그외에는 가독성을 해치는 굳이 필요는 코드라고 판단됨

def retrieve_user_detail_info(user_id:int) -> UserInfo:
    try:
        user: User = User.objects.get(user_id=user_id)
    except UserNotFoundError as error:
        logger.error("유저가 존재하지 않습니다")
        raise UserNotFoundError 
    else:        
        return UserInfo(user=user)


# case: 2
     # user_id를 기반으로 유저 정보를 DB에서 조회해서 가져오는데, 값이 없으면 None이 반환될 수 있다
     # 위와 마찬가지로 None일 경우를 하나의 예상된 케이스로 보고 처리를 해주고 있다
def retrieve_user_detail_info(user_id:int) -> UserInfo:
    user: None | User = User.objects.filter(user_id=user_id).first()
    
    if user is None:
        logger.error("유저가 존재하지 않습니다")
        raise UserNotFoundError
        
    return UserInfo(user=user)


def main(access_token: JWT):
    # access_token은 토큰 검증이 완료된 상태로 넘어온 것을 가정함
    user_id = access_token.auth.user_id
    return retrieve_user_detail_info(user_id)
```