# 2장 추상화 계층

### 2.2.1 추상화 계층 및 코드 품질의 핵심 요소

**가독성**

> 깨끗하고 뚜렷한 추상화 계층을 만드는 것은 개발자가 한 번에 한두 개 정도의 계층과 몇 개의 개념만 다루면 된다는 것을 의미한다. 따라서 코드의 가독성이 크게 향상된다.

추상화가 잘 되어 있는 인터페이스를 사용하면 확실히 사용하기 편했습니다.

C#에서 제공하는 `IEnumerable` 의 경우 이름만 봐도 상속 후 구현한 객체가 반복문을 돌릴 수 있는 객체가 된다는 것을 알 수 있듯이 확실히 추상화 계층이 깨끗하면 코드 가독성 또한 좋아지는 듯 합니다.

반대로 추상화가 너무 복잡하게 이루어진 구조에서 이를 변경하고 기능을 추가해야 하는 상황일 때는 가독성이 높다고 이야기 하긴 힘들 수도 있습니다.

복잡하게 설계 되어 있는 구조를 탐험해야 할 때는 개인적으로 구조를 그려가면서 코드를 분석하니깐 편했습니다.

서로 어떻게 데이터를 주고 받고 있는지 상속 구조는 어떻게 되어 있는지 등 객체 간 관계를 그려가면서 소스를 보면 기억에도 오래 남고 향후 해당 소스에 대한 이야기를 할 때도 요 문서가 도움이 될 때가 있었습니다.

한 가지 신기한 점은 최근 독해력을 높이기 위해서 어떤 방법이 있는지에 대한 간단한 영상을 본적이 있었는데요(링크: [https://youtu.be/Kz_HLk_ZBko](https://youtu.be/Kz_HLk_ZBko)). 여기서는 독해력을 높이기 위해서 정보 간 관계를 파악하는 것에 집중을 해야 한다고 합니다.

독해력을 높이는 방법과 마찬가지로 코드의 전반적인 구조를 잘 이해하기 위해서는 데이터들이 서로 어떤 관계를 가지고 있는지를 파악하고 이해하는 것이 중요해 보입니다.

### 2.3.2 함수

> 각 함수에 포함된 코드가 하나의 잘 써진 짧은 문장처럼 읽히면 이상적이다.
> 

클린 코드에서 이야기하는 하나의 함수는 한 가지 기능만 해야한다와 같은 맥락으로 보입니다.

하지만 모든 상황에서 한 가지 기능만 명시하기가 어려운 경우가 있는데 이럴 때 최대한 상위 레벨의 구현부에서는 한 가지 작업을 담당하는 로직을 구현하고 하위 레벨로 내려갈 수록 복잡한 작업을 나눠서 호출하는 식으로 구현을 하려고 합니다.

> 일단 함수를 작성했으면 작성된 코드를 문장으로 만들어보면 좋다.


요것도 나름 꿀팁인 것 같아 기록으로 남깁니다.

> 함수를 작게 만들어서 클래스 내에서 재사용하거나 헬퍼 클래스로 옮기고 퍼블릭 메서드로 변경할 수 있다.


여러 클래스에서 재사용을 해야하는 함수를 어떻게 구현을 하면 좋을지 항상 고민이 됩니다.

쉬운 방법은 helper class를 만들고 static 함수를 사용해서 구현하는 방식인데, 이렇게 구현하면 다양한 상황에서 유연하게 동작하기 어렵다는 점이 마음에 걸립니다.

해당 helper 함수를 조금씩 다른 방법으로 이용해야 할 때가 있기 때문에 위와 같은 방식을 고집한다면 유연하게 대처하기가 쉽지 않게 되죠.

조금 더 좋은 방식은 아무래도 헬퍼 클래스가 해야하는 역할을 인터페이스로 뽑아내고 해당 인터페이스를 상속 받은 각 클래스가 기능을 구현을 하고 요 함수를 필요하는 클래스에서 멤버 변수로 인터페이스를 들고 있다가 상황 별로 필요한 기능을 구현한 클래스로 변신(인스턴스화)을 시키면 조금 더 유연한 방식으로 사용이 가능할 것 같습니다.

### 2.3.3 클래스

> 응집력: 이것은 한 클래스 내의 모든 요소들이 얼마나 잘 속해 있는지를 보여주는 척도이다.


한 클래스에서 필요한 요소들이 필드 내부에 잘 정의가 되어 있을 때 응집력이 높은 상태입니다.

응집력이 높아 질 수록 클래스를 벗어나는 일이 적어지기 때문에 결합도를 낮출 수 있어 좋은 설계의 기준이 될 수 있습니다.

> 단일 클래스 내에 얼마나 많은 다른 개념이 들어가 있는지, 그리고 어떤 로직이 재사용이나 재구성에 적합한지에 대해 개발자가 신중하게 생각하지 않으면 클래스는 종종 너무 커진다.


처음부터 클래스를 관심사 별로 쪼개는 것은 쉽지 않은 것 같습니다.

따라서 일단 큰 덩어리로 구현을 하고 (중요)쪼개는 작업을 뒤로 미루지 않고 그 즉시 구현해 나가는 것이 중요해 보입니다.

큰 덩어리 클래스 하면 매번 생각나는 사례가 싱글톤 3000라인 객체도 괜찮다고 했던 팀장님이 생각이 나네요.

> 함수를 쪼개어 추상화 계층을 여러개 만든다 할지라도 한 클래스 내부에 이것들이 모두 존재하면 클래스 크기가 너무 커지게 된다. 이것은 추상화 계층들 사이의 분리가 그다지 뚜렷하지 않다는 것을 의미한다.
> 

```
텍스트 요약 클래스:
	최상위 문제: 텍스트 요약
		1계층 하위 문제: 문장을 분할
		1계층 하위 문제: 중요한 문장 계산
			2계층 하위 문제: 중요 명사 추출
			2계층 하위 문제: 중요 동사 추출
			2계층 하위 문제: 중요 형용사 추출
```

원래 해결해야 하는 문제는 텍스트를 요약하는 것인데 하위 문제로 들어갈 수록 점점 그것과는 멀어지는 것을 발견할 수 있습니다.

이를 해결해야하는 문제 집중해서 클래스를 나누고 추상화를 해본다면 아래와 같을 수 있습니다.

```
텍스트 요약 클래스:
	멤버: 문장을 분할하는 클래스
	멤버: 중요 문장을 계산하는 클래스
	
	최상위 문제: 텍스트 요약
		문장을 분할하는 클래스.문장을 분할
		중요 문장을 계산하는 클래스.중요한 문장 계산

문장을 분할하는 클래스:
	최상위 문제: 문장을 분할

중요 문장을 계산하는 클래스:
	최상위 문제: 중요한 문장 계산
		1계층 하위 문제: 중요 명사 추출
		1계층 하위 문제: 중요 동사 추출
		1계층 하위 문제: 중요 형용사 추출
```

### 2.3.4 인터페이스

> 단일 인터페이스 단일 구현


인터페이스를 사용하는 가장 큰 이유가 다형성 하나 뿐이라 생각했던 시절이 있었습니다.

하지만 최근 들어 인터페이스를 구현한 클래스가 단 하나 뿐이라도 의미가 있을 수도 있겠단 생각을 하게 됩니다.

외부에 노출하는 API를 인터페이스에 한정 시키는 것도, 의존성을 낮춰주는 것도 물론 의미가 있겠지만 조금 더 나아가 객체의 핵심 역할을 인터페이스를 통해 정의가 가능합니다. 

즉, 객체의 존재 의미를 인터페이스를 통해 외부에 노출이 가능하겠더라구요.

하나의 객체 담겨 있는 무수히 많은 코드 중 해당 객체가 하는 핵심은 인터페이스의 구현부로 판단이 가능하기 때문에 이것만으로도 단일 인터페이스 단일 구현이 의미가 있어 보입니다.

## 질문

1. 추상화가 잘 이루어져서 실제로 코드를 읽기 편했던 경험이 있을까요? 보통은 추상화 하면 코드를 복잡하게 만들기 때문에 가독성과는 거리가 먼 개념이라고 생각했는데 저자의 이야기를 듣고 아하! 했던 부분이 있었던 것 같습니다.
2. 단일 인터페이스 단일 구현을 실제로 접해본 경험 또는 구현을 해본 경험이 있으실까요? 있다면 어떤 목적이었을까요?