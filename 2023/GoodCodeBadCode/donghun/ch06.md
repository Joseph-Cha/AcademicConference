# 6장 예측 가능한 코드를 작성하라

### 질문

1. 실제로 런타임에서 발생할 수 있는 오류를 처리하는 방식은 크게 보면 호출하는 쪽(caller)에서의 오류를 처리하는 방식과 호출이 되는 쪽(callee)에서의 오류를 처리하는 방식 이렇게 2가지로 나뉘어 지는 것 같습니다. 호출하는 쪽에서 오류를 처리하게 되면 함수 호출하기 전에 전달해야 하는 매개변수를 사전에 검사를 하고 호출이 되는 쪽(callee)에서의 오류를 처리하는 방식은 함수 본문에서 매개변수를 검사하게 됩니다.
각자 어떤 방식을 선호하실까요?(또는 사용하고 있을까요?) 그리고 어떤 이유로 선택을 하셨을까요?

## 6.1 매직값을 반환하지 말아야 한다

### 6.1.2 해결책: 널, 옵셔널 또는 오류를 반환하라

> 값이 없을 수 있는 경우 이것이 코드 계약의 맹백한 부분에서 확인할 수 있도록 하는 것이 훨씬 좋다.
> 

예시에 나온 코드와 같이 nullable 값을 반환하도록 수정하는 것이 예측할 수 없는 매직 값보다 안전성이 좋아 보이는 것은 사실입니다.

다만, 사용 중인 언어가 nullable 값에 대한 안정성을 보장해 주지 않는다면(swift의 guard let 구문같이) null일 경우를 대비해 꼼꼼히 처리를 해야 하는 것도 사실입니다.

null일 경우 확인하기 위해서 언어별로 다양한 전략이 있겠지만 C#에서 제공해 주는 처리 방식이 개인적으로 직관적이라 좋아합니다.

예시의 코드를 C# + ? 연산자를 사용한다면 아래와 같이 표현이 가능합니다.

```cpp
double? getMean(List<User> users)
{
    if (!users.Any())
    {
        return null;
    }
    double? sumOfAges = 0.0;
    foreach (var user in users)
    {
        sumOfAges += (double)user?.getAge(); // user가 null일 경우 getAge 호출 x
    }
    return sumOfAges / (double)users.Count;
}
```

## 6.2 널 객체 패턴을 적절히 사용하라

### 6.2.1 빈 컬렉션을 반환하면 코드가 개선될 수 있다.

> 함수가 리스트, 집합, 배열과 같은 컬랙션을 반환할 때 컬렉션의 값을 얻을 수 없는 경우가 있다. 값이 지정이 안됐다거나 주어진 상황에서 컨렉션에 값이 없을 수 있다. 이 경우 한 가지 방법은 널 값을 반환하는 것이다.
> 

요 부분은 실제로 구현된 부분에서도 쉽고 효과적으로 적용할 수 있는 방법으로 보입니다.

실제로 컬렉션을 반환해야 할 때는 조건에 따라 null을 반환하는 경우가 거의 대다수였기 때문이다.

다만 이런 식으로 매번 새로운 객체를 생성해서 반환을 하게 되었을 경우 Garbage Collector가 열 일(?)을 할 가능성이 있기 때문에 성능에는 악영향을 미칠 수 있다는 것도 고려해야 할 포인트라고 생각합니다.

### 6.2.4 널 객체 구현은 예상을 벗어나는 동작을 유발할 수 있다

> 널 안전성과 옵셔널을 사용하는 것이 인기를 얻음에 따라 ‘값이 없음’을 훨씬 쉽고 안전하게 나타낼 수 있게 되었다. 이와 함께 널 객체 패턴의 사용을 지지하는 기존의 주장들 중 많은 것들이 요즘에는 설득력이 떨어졌다.
> 

컬렉션을 반환하는 경우에는 빈 컬렉션을 반환하는 전략이 유용하지만 이를 제외하고는 널 안전성을 사용하는 방식이 더 좋다는 이야기로 해당 챕터가 마무리되었습니다.

널 객체를 전달하는 것도 한 번쯤은 생각해 볼 만한 전략이란 생각이 들지만 요즘 언어적으로 null에 대한 체크 기능을 잘 제공해 주고 있기 때문에 널 객체 구현까지는 굳이라는 생각이 듭니다.

## 6.4 입력 매개변수를 수정하는 것에 주의하라

### 6.4.1 입력 매개변수를 수정하면 버그를 초래할 수 있다

> 입력 매개변수를 수정하는 것은 함수가 외부의 무언가에 영향을 미치기 때문에 부수 효과의 또 다른 예이다.
> 

일단 예시가 자극적이면서 적절하다는 생각이 듭니다.

다른 사람에게 빌려준 내 소중한 클래스가 그 사람으로 인해 손상이 될 수 있다면 세상 속상할 것 같습니다.

아무튼 본문으로 돌아와서, deep copy가 되는 타입의 경우에야 값이 새롭게 복사가 되어 매개 변수로 넘겨도 원본 값이 변경될 여지는 없어 보이지만 shallow copy가 되는 참조 타입의 경우는 원본 객체 데이터의 주솟값을 그대로 넘기기 때문에 원본 데이터가 변경될 여지가 충분히 있습니다.

물론 언어별로 참조 타입을 복사할 때 deep copy를 지원하는 방식을 사용하는 것도 한 가지 방법이 될 수 있단 생각이 듭니다.

## 6.5 오해를 일으키는 함수는 작성하지 말라

### 6.5.2 해결책: 중요한 입력은 필수 항목으로 만들라

> 어떤 매개변수 없이는 함수가 수행하려는 작업을 못 하는 경우 그 매개변수는 해당 함수에 중요하다.
> 

중요한 입력 값에 대해서 함수 내부에서 체크 후 예외를 던지는 방법을 사용할 수도 있지만 이렇게 했을 경우 런타임에서만 에러를 발견할 수 있기 때문에 함수를 사용하는 시점에서는 알 수가 됩니다.

따라서 책의 예제에서 나온 `@CheckReturnValue` annotation이 좋은 방법으로 보입니다.

그리고 `displayLegalDisclaimer()`를 바로 사용하는 것이 아니라 `ensureLegalCompliance()`로 한번 감싸서 계층 구조를 만든 부분이 흥미로웠습니다.

사용자 입장에서는 상위 계층에 있는 `ensureLegalCompliance()`를 호출할 때 정상적으로 원하는 동작이 이루어졌는지를 `boolean`을 통해 확인할 수 있기 때문에 반드시 동작해야 하는 작업에 대해서 확실하게 체크하고 넘어갈 수 있습니다. 더불어 계약도 명백하고요.

반드시 동작을 시켜야 하는 함수를 설계할 때 사용하기 좋은 패턴으로 보입니다.

## 6.6 미래를 대비한 열거형 처리

### 6.6.3 기본 케이스를 주의하라

> 스위치 문에 기본 케이스를 추가하면 컴파일러는 나중에 해당 열거형에 새 값이 추가되더라도 스위치 문이 모든 값을 처리한다고 판단한다. 즉, 컴파일러는 경고를 출력하지 않기 때문에 컴파일러가 제공하는 추가적인 보호는 받을 수 없다.
> 

열거형을 사용했을 경우 switch case 문으로 분기 처리하는 것은 너무나 익숙한 방법이고 더불어 default case를 작성하는 것도 때론 귀찮긴 하지만 안전한 방법이기에 챙기기 힘쓸 것입니다.

다만 신기했던 건, 본문 예제에서 나온 switch case 문밖에서 예외를 던지는 방식입니다.

case 문 내부에서 원하는 값을 반환하는 구조일 때 사용이 가능한 방법이기는 하지만 default case가 없기 때문에 사용하는 언어에 따라서 컴파일러의 도움을 받을 수 있는 방법이기에 유용해 보입니다.

다만 이 또한 언어의 특성에 따라 default case가 없어도 컴파일 에러가 발생하지 않을 수도 있기 때문에 기본적으로 default case + 예외 처리 방식이 기본이지 않을까 싶습니다.

## 6.7 이 모든 것을 테스트로 해결할 수는 없는가?

> 그러나 예상을 벗어나는 코드를 피하는 것은 여러분이 작성한 코드에 대한 기술적 정확성 때문만은 아니다. 다른 개발자가 여러분의 코드를 사용해 코드 작성을 할 때 역시 그 코드가 올바르게 작동하도록 하기 위한 작업니다.
> 

해당 주제와는 다소 거리가 있는 부분이긴 하지만 예측 가능한 코드를 작성해야 하는 가장 근본적인 이유에 대한 내용인 것 같아서 인용문으로 남깁니다.

결국 사용자 입장에서 함수를 사용하기 전 여러 가지 경우에 대해서 사전 점검을 하고(ex. 함수에 필요한 매개변수를 체크하는 등) 사용하는 것이 아니라 믿고 일단 사용할 수 있는 코드를 작성하는 것이 요번 장의 핵심으로 보입니다.