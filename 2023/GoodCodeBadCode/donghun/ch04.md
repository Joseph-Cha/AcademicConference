# 4장 오류

### 4.1.1 복구 가능한 오류

> 낮은 층위의 코드에서 오류를 시도하고 복구하는 것은 장점이 별로 없고, 오류 처리 방법을 알고 있는 더 높은 층위의 코드로 오류를 전송해야 하는 경우가 많다.

예를들어 디스크에서 이미지 파일을 읽는 함수를 호출했을 때 디스크 파일에 접근 중 오류가 발생했다면 해당 오류를 디스크를 접근하는 쪽에서 처리를 하는 것이 아니라 이미지 파일을 읽는 함수를 호출하는 쪽에서 처리하는 것이 사용자에게 오류를 전달하는 좋은 방법으로 보입니다.

### 참고) 복구 가능한 오류 vs 복구할 수 없는 오류 정리

| dd | 복구 가능한 오류 | 복구할 수 없는 오류 |
| --- | --- | --- |
| 정의 | - 시스템 외부에서의 무언가로 부터 발생 <br> - 오류가 발생되더라도 프로그램은 계속 동작 가능한 오류 | - 주로프로그래밍 오류 때문에 발생 <br> - 오류가 발생했을 때 프로그램을 종료해야 하는 오류 |
| 사례 | - 잘못된 사용자 입력 <br> - 네트워크 오류 <br> - 중요하지 않은 작업 오류  | - 코드와 함께 추가되어야할 리소스가 없음 <br> - 잘못된 인수로 호출 |
| 해결책 | - 유효하지 않다는 오류 메시지 제공 | - 피해를 최소화 하고 개발자가 문제를 발견 후 해결할 가능성을 최대화(신속한 실패, 요란한 실패) |

### 4.1.4 호출하는 쪽에서 복구하고자 하는 오류에 대해 인지하도록 하라

> 시스템 외부에서의 무언가로 부터 오류가 발생할 가능성이 높은 함수를 작성할 때는 이 함수에서 오류가 발생할 수 있다는 가능성을 호출하는 쪽에서 확실하게 인지하도록 해야 한다.

낮은 층위에서 구현된 함수를 사용할 때를 생각해 보면, 여기서 오류가 발생할 수도 있겠단 생각보다 무턱대고 믿고 사용하는 경향이 있습니다. 즉 오류에 대해서 아무런 처리도 하지 않고 넘기는 경우가 다반사죠.

다른 언어는 잘 모르겠지만 C#의 경우는 메서드 시그니처만 봐서는 해당 함수에서 어떤 오류를 던지는지 알 수 없고 보통 API 문서를 봐야 알 수 있습니다(→ 해당 챕터 후반부에 설명한 `MustUseReturnValue` annotation을 통해 확인이 가능하다는 것을 알게 되었습니다!)

API를 사용하기 전 가이드 문서를 한 번쯤 보는 것도 해당 API를 설계한 개발자와의 계약을 지키는 방법일 수도 있겠네요.

|  | 견고성 | 실패 |
| --- | --- | --- |
| 오류 발생 시 처리 방법 | 오류를 처리하고  낮은 층위 코드를 이어서 진행 | 더 높은 층위에서 오류를 처리 또는 프로그램 종료 |
| 오류 종류 | 복구 가능한 오류 | 복구할 수 없는 오류 |

### 4.2.1 신속하게 실패하라

> 오류가 발생했을 때 신속하게 실패하지 않으면, 오류는 실제 위치에서 멀리 떨어진 코드에서 나타날 수 있다.

최근에 딱 위와 같은 사건 때문에 골치가 아픈 적이 있었는데요.

저희 팀에서 제공하는 API를 타팀에서 한번 더 래핑 후 최종 사용자에게 제공하는 형태인데요. 최종 사용자의 잘못된 입력 값을 타팀에서 체크를 해주지 않아서 저희팀에서 제공하는 API의 try catch문에 null exception이 잡힌 적이 있었습니다.

여기서 더 골치가 아팠던 게 저희팀에서 제공하는 API가 타팀의 callback 로직 내부에서 호출이 되었었기 때문에 어느 시점에서부터 잘못된 입력이 들어왔는지 파악하기가 더욱 힘든 상황이었습니다.

사용자 입장에서는 에러가 발생한 stack trace문에 저희 측 코드가 최상단에 있다보니 당연히 저희 쪽 코드 문제로 오해를 했고 이를 해결하기 위해 암만 저희 쪽 소스로 재현을 해봤지만 재현도 안됐었죠.

여차여차해서 타팀과의 협업을 통해 문제를 해결했지만 해결 했던 과정이 너무 고통스럽기만 했습니다.

사용자의 잘못된 입력 값에 대해서는 해당 값을 가장 처음 사용하는 시점에 확인을 하는 것이 정말 정말 좋아보입니다.

### 4.2.3 복구 가능성의 범위

> 일반적으로 소프트웨어를 견고하게 작성하는 것이 좋다. 한 번의 잘못된 요청으로 인해 전체 서버의 동작이 멈추는 것은 바람직하지 않다. 그러나 오류를 알아차리지 못한 채 시스템이 계속 동작하지 않도록 하는 것 또한 중요하기 때문에 코드가 요란하게 실패해야 한다. ..중략.. 이어 대한 해결책은 프로그래밍 오류가 발견되면 개발자가 이를 알아차릴 수 있도록 프로그램 오류를 기록하고 모니터링 하는 것이다.

프로그램 실행 중 발생하는 치명적인 오류에 대해 무조건 시스템을 종료 시키는 것이 아니라 해당 오류를 개발자에게 알리는 것도 좋은 방법이라고 합니다.

이와 같은 이유 때문에 Logger 서비스를 다양한 회사에서 제공을 하는 것으로 보입니다.

지금까지 단순히 log를 출력하는 형태로만 오류를 모니터링 했는데 Logger 서비스를 사용하면 웹 콘솔에서 이런 오류를 모니터링 할 수 있어서 조금 더 편하게 시스템 오류를 모니터링 할 수 있기 때문에 규모가 있는 개발 부서에서 많이 애용하는 것으로 알고 있습니다.

### 4.2.4 오류를 숨기지 않음

**기본값 반환**

> 기본값의 문제점은 오류가 발생했다는 사실을 숨긴다는 것인데, 이는 코드를 호출하는 쪽에서 모든 것이 정상인 것처럼 계속 진행한다는 것을 의미한다.

비정상적인 상황에서 기본값을 반환하는 것이 아니라 예외를 던지는 처리가 사용하는 입장에서 오류를 빠르게 확인할 수 있는 방법입니다.

**널 객체 패턴**

> 오류가 발생했을 때 null 객체를 반환했을 때 오류 파악을 빠르게 할 수 없다.

특정 상황일 때 널 객체를 반환하는 처리를 자주 사용하게 되는데 상황에 따라 예외를 던지는 방법으로 처리를 해야겠다는 생각이 듭니다.

**아무것도 하지 않음**

> 코드가 하는 일에 대해 개발자가 가지고 있는 정신 모델과 코드가 실제로 수행하는 것 사이의 불일치를 일으킬 가능성이 매우 높다.

오류를 대하는 가장 중요한 마음 가짐으로 보입니다. 내가 작성한 함수를 호출하는 쪽에서 정상적으로 사용하지 않을 수도 있다는 점을 항상 명심하는 자세가 중요해 보입니다.

## 4.3 오류 전달 방법

명시적 방법: 코드를 호출한 쪽에서 오류가 발생할 수 있음을 인지할 수밖에 없도록 한다(ex. throw exeption).

암시적 방법: 문서를 통해 오류를 알린다.

### 4.3.4 명시적 방법: 널값이 가능한 반환 유형

> 사용 중인 언어가 널 안전성을 지원하는 경우 널값이 반환될 수 있다는 것을 호출하는 쪽에서 강제적으로 인지하고, 그에 따라 처리할 수밖에 없다.

대표적으로 swift의 경우 옵셔널 바인딩을 통해 nil(null과 동일한 개념) 안전성을 제공해 주고 있습니다.

예를들어,

```swift
// guard let -> hasURL이 null일 경우 예외처리
guard let hasURL = URL(string: urlString) else {
    throw Error.badRUL
}
var request = URLRequest(url: hasURL)
```

```swift
// if let -> data가 null이 아닐 경우 내부 로직 실행
if let hasData = data {
    complection(UIImage(data: hasData))
    return
}
```

위와 같이 swift에서는 옵셔널 값을 사용할 때 강제로 옵셔널 값을 추출하거나(data!) 옵셔널 바인딩을 해야만 컴파일 에러가 발생하지 않기 때문에 다른 언어들 보다 옵셔널에 대한 안정성을 보장해 주고 있습니다.

### 4.3.5 명시적 방법: 리절트 반환 유형

책에서 언급한 swift를 활용한 리절트 유형을 사용하면 아래와 같이 예제 코드를 사용할 수 있습니다.

```swift
enum SquareRootError: Error {
     case erroneousNumber
}

func getSquareRoot(value: Double) -> Result<Double, SquareRootError> {
	if value < 0.0 {
		return .failure(.erroneousNumber)
	}
	return .sucess(Math.sqrt(value))
}

// 실제 사용 예
let result: Double = getSquareRoot(ui.getInputNumber());
switch result {
	case .success(let value) {
		ui.setOutput("Square root is: " +  value.description)
	}
	case .failure(let error) {
		ui.setError("Cant't get square root of negative number: " + error)	
	}
}
```

`getSquareRoot`의 반환 값을 Result 타입으로 해서 원하는 값과 에러 처리를 조금 더 간편하고 적은 수의 코드로 result 반환을 구현할 수 있습니다. 또한 반환 타입이 result 유형이라는 것을 명확히 알 수 있기 때문에 호출하는 쪽에서도 오류 처리에 대한 부분을 명시적으로 알 수 있습니다.

### 4.3.6 명시적 방법: 아웃컴 반환 유형

> 함수가 수행한 동작의 결과를 나타내는 값을 반환하도록 함수를 수정하는 것이 한 가지 방법이 될 수 있다.

책에서 나온 예제와 마찬가지로 함수의 결과를 void 타입이 아닌 boolean 타입과 같은 결과 값으로 알려주는 것도 오류를 명시적으로 알려주는 방법입니다.

### 4.3.7 암시적 방법: 프로미스 또는 퓨처

> 프로미스나 퓨처를 반환할 때 명시적 오류 전달 기법으로 사용하려면, 리절트 유형의 프로미스를 반환하는 것이 한 가지 방법일 수 있다.

프로미스를 활용한 비동기 로직 구현과 리절트 유형이 만나면 진짜 유용하다는 생각이 듭니다.

하지만 그만큼 코드가 복잡해 질 수 있기 때문에 꼭 필요한 상황에 사용해야할 것 같습니다.

## 4.5 호출하는 쪽에서 복구하기를 원할 수도 있는 오류의 전달

> 먼저 기억해야 할 점은 여러분과 여러분의 팀이 동의한 철학이 다른 어떤 주장보다도 중요하다는 점이다.

역시 로마에 가면 로마법을 따르는 것이 국룰인 듯합니다.

덧붙여 저희 팀 같은 경우는 java 쪽 소스로 작업하시는 분들은 명시적인 방법을 선호하시는 것 같고 C#의 경우는 비검사 예외를 주로 사용하고 있습니다.

예외 처리에 대한 내용을 한 번 공유해서 서로 의견을 나눠보는 시간이 있으면 좋겠단 생각이 드네요.

### 4.5.2 명시적 기법을 사용해야 한다는 주장

> Timer.schedule()은 새로운 스레드를 시작하기 때문에 스케줄된 코드에서 발생하는 어떠한 예외도 이 계층 이상으로 올라가지 않는다.

별도의 새로운 스레드에서 발생한 예외가 main 스레드에서 잡히지 않는 다는 것인데 이와 관련해서 참고할 만한 글이 있어서 공유합니다. 요 글을 통해 별도의 스레드에서 발생한 예외 처리를 어떻게 하면 적절하게 처리할 수 있는지에 대해서도 알 수 있었습니다.

- [Java Thread 내에서 발생한 Exception 처리](https://github.com/HomoEfficio/dev-tips/blob/master/Java-Thread%EB%82%B4%EC%97%90%EC%84%9C-%EB%B0%9C%EC%83%9D%ED%95%9C-Exception-%EC%B2%98%EB%A6%AC.md)

### 4.5.3 필자의 의견: 명시적 방식을 사용하라

> 호출하는 쪽에서 복구하기를 원할 수도 있는 오류에 대해 비검사 예외를 사용하지 않는 것이 최상이라는 것이 필자의 의견이다.

여기가지 오면서 필자가 전달한 내용을 쭉 읽어가면서 이미 설득을 당해버린 느낌입니다.

C#에서는 비검사 예외만을 제공하는 것으로 알고 있었는데 `MustUseReturnValue` 라는 애너테이션을 알게 되어 없어서 못한다라는 핑계조차 댈 수가 없는 상황이 되어버렸네요.

## 질문

1. 초심자에게 쉬운 것 같으면서 또 어려운 부분이 오류를 처리하는 방법인 것 같습니다. 책에서 굉장히 디테일하고 풍부한 사례를 통해 오류를 처리하는 방법을 설명해 주었는데요. 이 중에서 가장 유용하다고 느꼈던 방법론이 있다면 어떤 게 있을까요?
2. 개인적으로 코드를 구현할 때 “무슨 오류가 있겠어” 하며 안일하게 짜는 경우가 많이 있었습니다. 혹시 이와 비슷한 경험을 해본 적이 있을까요? 그리고 적절하게 오류처리를 하지 않았기 때문에 겪었던 에피소드가 있다면 공유 부탁드립니다.