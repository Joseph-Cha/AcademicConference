# 4장. 실용주의 편집증

## 서문

편집증이란 단어가 생소해서 사전을 검색해봤다.

```
**편집증**(偏執症) 또는 파라노이아(영어: paranoia)는 심각한 걱정이나 두려움으로 
자신이 주변으로부터 피해를 받을 것이라는 병리적인 의심을 고집하는 이상심리학적 상태를 일컫는다.
```

개발자에게 있어서 편집증이란 내가 만든 프로그램을 항상 의심하는 것이고, 결코 완벽할 수 없다는 것을 인지하며 방어적인 자세로 자신의 코드를 바라보는 자세를 뜻하는 것 같다.

좀 더 나아가면 들어올 입력 값을 의심하며 항상 대비하는 자세를 의미한다.

더 깊이 들어가면 나 자신마저 의심을 하라고 하는데 이건 좀 너무 나아간 것 같고,,

아무튼 내가 만든 코드가 완벽하다는 확신은 언제나 위험하다. 이렇게 짜는 것이 안전한지 혹시 예상하지 못한 상황에서는 어떻게 동작할지 스스로 되묻는 과정이 필요하다는 점에 동감한다.

Q) 극단적으로 모든 입력 값을 다 체크하는 것이 맞을까 하는 생각도 듭니다만.. 보통 함수에 필요한 데이터를 콜 하는 쪽에서 확인을 하나요, 아니면 함수 내부에서 확인을 하시나요?

## Topic 23 계약에 의한 설계

Design By Contract, DBC. 계약에 의한 설계라는 낯선 개념이 등장한다.

> 만약 호출자가 루틴의 모든 선행 조건을 충족한다면 해당 루틴은 종료 시 모든 후행 조건과 불변식이 참이 되는 것을 보장한다.
> 

일단 호출하는 쪽에서 루틴에서 요구하는 모든 조건을 지킨다면 루틴 또한 호출하는 쪽에서 요구하는 것을 적절하게 전달해 준다는 의미인 것 같다.

즉, 호출하는 쪽과 루틴을 처리하는 쪽 모두 각자가 계약을 걸어서 양쪽 모두 책임을 지도록 한다.

이런 계약을 지원하는 언어가 있다고 하는데 한 번도 접해본 적이 없어서 다소 낯설긴 하다.

호출할 때 적절한 인자를 전달하는지 체크하고 루틴을 처리하는 쪽에서도 호출하는 쪽에 원하는 값을 적절히 전달해 주는지 확인하는 것은 확실히 코드의 안전성을 높이는 방법인 것 같다.

그리고 본문에서 나온 단정문 파트에서 부모 클래스에서 정의한 메서드를 자식 클래스가 재정의할 때 부모 메서드의 단정문을 사용할 수가 없다는 이야기가 나오는데, 이건 C#에서 제공해주는 base 키워드를 사용하면 해결할 수 있을 듯 싶다.

Q) 평소 하나의 함수를 만들 때 들어오는 인자의 값을 확인하는 편인가요? 보통 위에서 말하는 계약 패턴을 지키기 보다 루틴 속에서 인자를 확인하는 것이 조금 더 안전하게 느껴지는 것 같은데 각자의 생각이 궁금합니다.

## Topic 24 죽은 프로그램은 거짓말을 하지 않는다

> 가능한 한 빨리 문제를 발견하면 좀 더 일찍 시스템을 멀춤 수 있으니 더 낫다. 게다가 프로그램을 멈추는 것이 할 수 있는 최선인 경우가 흔하다.
> 

요건 조금 생소한 개념으로 다가왔다. 하지만 나름 납득은 되었던 게 어정쩡하게 이상하게 돌아가는 코드보다 그리고 모든 부분을 try catch로 묶어서 처리하는 것보다 일단 에러가 발생하면 프로그램이 멈추도록 하는 게 더 나아 보이기는 하다. 

## Topic 25 단정적 프로그래밍

처음에는 단정적이라는 의미가 if 문을 사용하는 것으로 이해했는데 알고 보니 assert를 통해 코드를 검증하는 것이었다. 단순히 해당 코드가 오류인지 아닌지를 체크하는 용도는 아니다.

본문에서는 object가 null 인지 여부를 단정문으로 많이 검증을 하는데 C#에서 제공해 주는 “?” 키워드를 사용하면 조금 더 객체를 안전하게 사용할 수 있는 것과 비슷한 것 같아 보인다.

## Topic 26 리소스 사용의 균형

C#의 경우 메모리 해제를 GC가 알아서 해주기 때문에 리소스 생성 및 해제를 그렇게까지 걱정하지 않아도 괜찮다.

다만, GC가 워낙 무거운 로직이기 때문에 최대한 덜 GC가 돌도록 리소스를 재활용하는 것이 좋긴 하지만.. 아무튼 크게 걱정할 부분이 아니란 건 사실이다.

다만 C#에서도 직접 메모리를 해제해야 하는 클레스가 존재하는데 주로 IO 처리를 담당하는 클래스가 그러하다.

이런 특별한 경우를 위해서 몇 가지 유용한 기능을 제공을 하는데 간단히 소개하면..

```csharp
using(var imgFileStream = new FileStream(imgFilePath, FileMode.Open)) 
{ 
		var tmpImg = Image.FromStream(imgFileStream)
}
```

요렇게 using 문으로 객체를 감싸면 해당 블록을 벗어날 때 자동으로 dispose를 시켜줘서 편하게 리소스를 사용할 수 있다.

요즘은 더 나아가서 이렇게도 쓸 수 있다고 한다.

```csharp
using var imgFileStream = new FileStream(imgFilePath, FileMode.Open);
var tmpImg = Image.FromStream(imgFileStream);
```

이렇게 하면 using이 선언된 범위까지 생명이 연장된다고 한다.

## Topic 27 헤드라이트를 앞서가지 말라

> 작은 단계들을 밟아라. 언제나.
> 

현재 맡은 작업을 최대한 쪼개는 능력이 갈수록 중요해지는 것을 느끼고 있다. 

단순히 편하게 작업을 하기 위함이라기 보다 담당하고 있는 작업의 진척을 공유할 때 특히 유용한 방법이기 때문이다. 

그리고 본문에서 나온 것처럼 한 번에 너무 큰 범위를 잡고 작업을 시작하게 되면 예측하는 범위 또한 매우 넓어지기 때문에 작업 중인 요구사항에 따른 설계 범위도 매우 커지고 이에 따라 처음 작업한 설계가 계속 바뀌게 된다(이런 악순환이 반복되다 보면 어차피 설계가 바뀔 텐데 굳이 왜 설계를 해야 할까하면서 바로 바로 코드부터 짜는 습관이 생기게 된다).

따라서 최대한 적은 범위로 작업을 쪼개고 해당 범위에 맞는 설계를 하고 코드를 짠 다음에 설계를 수정해 가는 방식을 사용하도록 꾸준히 연습할 필요가 있는 것 같다.