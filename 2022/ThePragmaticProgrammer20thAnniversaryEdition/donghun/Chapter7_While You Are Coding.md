# 7장. 코딩하는 동안

## 개요

> 일단 코딩에 들어가면 대부분 기계적인 작업, 즉 설계 내용을 컴퓨터가 실행할 수 있는 문장으로 바꾸는 일만 하면 된다고 많이 생각한다. ..중략.. 이러한 태도가 프로젝트가 실패하는 가장 큰 원인이다.
> 

진짜 아무 생각 없이 일단 동작만 시키면 된다는 마인드로 구현을 하기 시작하면 원하는 목표를 이룰 수 있는 것 같다. 진짜 딱 동작만 한다는 목표를.

훗날 내가 짠 코드를 수정 해야하는 상황이 온다면 인터스텔라의 한 장면이 생각나지 않을까?

따라서 읽고 분석하기 쉬운 코드를 쓰는 것은 매우 중요하다는 메시지에 매우 동감하고 아직 많이 부족하지만 내가 구현한 코드에 대해서 생각하고 또 생각하려고 노력하고 있다.

## Topic 37. 파충류의 뇌에 귀 기울이기

마치 스파이더맨 센서처럼 코딩을 하는 동안 자신의 본능을 무시하지말라는 내용이 나온다.

생각으로 표현할 수는 없지만 말할 수 없는 찝찝함이 있다면 그냥 넘기지 말고 한번 더 살펴보라는 맥락인 것 같다.

이러한 본능이 나름 타당할 수 있는 이유는 개발자로서의 경험과 지혜가 축적된 결과라고 한다.

이어서 이런 생각을 다룰 수 있는 방법에 대해서 이야기를 하는데 첫번째는 현재 있는 환경에서 벗어나 머리를 환기를 시켜보는 것이고, 이어서 의심적인 부분을 프로토 타입 형태로 구현을 해보는 것이다. 이를 통해 현재 가지고 있는 의심적인 부분을 프로토 타입핑을 통해 구체화를 시킬 수도 있다.

> 이상하게 생각되는 부분을 그냥 넘기지 말고 적극적으로 분석해보자.
> 

위 문장이 해당 챕터를 요약하는 한 문장이 될 것 같다.

Q) 코딩을 하다가 위와 같은 경험을 해본 적이 있을까요?(먼가 의심이 되고 불안하지만 이것이 왜인지를 바로 설명하기는 힘든 상황)

## Topic 38. 우연에 맡기는 프로그래밍

> 코드가 어떻게 동작하는지 알지 못하는 상태에서 프로그래밍을 하는 것이 곧 우연에 맡기는 프로그래밍이다. 
애초에 동작을 잘 할 수 있었던 이유는 제한된 환경에서 테스트를 했기 때문이다.
> 

유니티에서 제공해주는 API들을 그래도 믿고 사용해도 된다는 생각을 하고 있는데 기타 라이브러리 또는 스택 오버 플로우 등에서 긁어온 코드의 경우는 무턱대고 믿고 사용하는 경향이 있는 것 같다.

> 가정을 기록으로 남겨라
> 

특히 스택 오버 플로우 등과 같은 외부 사이트에서 얻어온 소스의 경우는 주석을 통해서 어떤 과정에 의해 해당 소스를 긁어왔는지 남겨두는 것도 괜찮은 방법일 듯 싶다.

> 가정하지 말라. 증명하라.
> 

획득한 또는 사용한 API들에 대해서 최대한 다양한 케이스의 테스트를 시도해야겠다는 생각이 든다.

다음과 같이 우연이 아니라 의도적으로 구현을 해보자

- 경험이 적은 개발자에게도 설명이 가능한지 체크
- 완전히 이해하지 못한 기술을 섣불리 사용하지 말라
- 신뢰할 수 있는 것만 사용
- 가정을 기록으로 남기기(이렇게 동작될 것이라고 생각되는 내용을 정리해서 기록에 남기기)
- 세운 가정을 충분히 테스트 해보기

Q) 검색을 통해 얻은 소스를 활용할 때 어떤 방식으로 소스를 검증하고 계신가요? 저와 같은 경우는 해결이 됐다는 댓글이 보이면 일단 긁어서 써보고 동작하면 그냥 넘어가고 있습니다..ㅎㅎ

## Topic 39. 알고리즘 속도

알고리즘 성능을 테스트하기 위한 방법으로 가장 유명한 빅오 표기법이 등장한다.

빅오 표기법은 이미 너무 유명하기 때문에 설명하는 부분은 생략하고.. 실무에서 과연 제곱(그래도 여기까지는 나름 이해가 된다), 세제곱, 지수에 해당하는 구현을 할 일이 있을까 싶다..?

개인적으로 for문을 도는 것도 엥간하면 지양하려고 하고 있고(switch case도 엥간하면 역시 지양하려는 편) Hash 맵으로 돌려서 구현할 수 있는지 생각해 보고 있다.

Q) 실무에서 구현한 부분의 알고리즘 성능에 대해서 리뷰를 주고 받은 적이 있으실까요? 

## Topic 40. 리팩터링

> 소프트웨어 개발은 건축보다 정원 가꾸기에 더 가깝다.
> 

소프트웨어 개발 하면 설계를 빼놓을 수 없기 때문에 당연히 소프트웨어 개발의 메타포는 건축이라고 생각했었다. 

하지만 왠걸, 막상 정원 가꾸기 비유들어보니 정원 가꾸기가 훨씬 더 정확한 표현이라는 것을 알게 되었다. 루틴을 관리하는 것은 곧 너무 크게 자라는 나뭇가지를 정리하는 것과 비슷하고 불필요한 소스를 매번 제거하는 것은 잡초를 뜯는 것과 유사하다는 결론이 너무나 설득력 있었다.

> 리팩터링에서 밥 아저씨는 아래 두가지가 리팩터링에 핵심이라고 한다.
1. 리팩터링은 체계적이여야 한다.
2. 밖으로 드러나는 동작은 바뀌지 않는다.
> 

핵심은 역시 밖으로 드러나는 동작이 바뀌면 안된다는 것으로 보인다. 

더 나아가 밖으로 드러나는 동작은 단위 테스트를 통해 이미 검증이 되어 있어야 한다고 한다.

> 리펙터링은 언제 하는가? 바로 지금이 적기이다.
> 

이미 앞서 읽은 많은 책들에서 언급한 내용이기도 하고 멘토님을 통해 익히 들었던 이야기이기도 하다. 리펙토링을 위해 시간을 달라고 하는 것은 적절하지 못하다. 단지 구현에 필요한 시간에 매순간 하게 되는 리펙토링 시간이 포함되어 있어야 한다.

> 리펙터링을 하는 이유
1. 중복
2. 직교적이지 않은 설계
3. 더 이상 유효하지 않은 지식
4. 사용 사례 → 중요하다고 생각했던 부분이 중요하지 않고 중요하지 않은 부분이 생각보다 중요할 수 있음
5. 성능 개선
6. 테스트 통과 → 테스트 통과가 밑바탕이 된다면 언제든 리펙터링이 가능하다.
> 

리펙터링을 위해 코드를 수정하는 것에 두려워하지 말자

> 리펙터링을 어떻게 하는가?
1. 기능 추가와 리펙토링을 동시에 하지는 말자
2. 리펙터링을 시작하기 전 든든한 테스트 코드가 있어야 한다.
3. 단계를 작게 나누어서 신중하게 작업
> 

특히 단계를 나눠서 진행해야 하는 것에 밑줄 쫙. 

무턱대고 모든 코드를 다 바꾸는 것이 아니라 스텝 바이 스텝으로 단계를 쪼개서 단계가 끝나면 테스트를 돌려보는 식으로 작업을 진행해 보자.

Q) 본인 만의 리펙터링을 하는 팁이 혹시 있을까요? 더불어 가장 많이 리펙터링을 하게 되는 이유는 무엇인가요?

## Topic 41. 테스트로 코딩하기

> 이제는 테스트 코드를 왜 짜야하는지에 대한 당위성에 대해서는 많이 동감을 하는 것 같다. 
그렇다면 테스트의 가장 중요한 가치는 무엇일까?
테스트의 가장 중요한 이유는 테스트를 실행할 때가 아니라 테스트에 대해서 생각하고 테스트를 작성할 때 생긴다.
> 

해당 챕터를 읽으면서 머리를 한 대 맞은 느낌이었다. 

그동안 테스트 코드를 짜야하는 이유를 안정성이라는 이유로 다양한 테스트 케이스에 대해서 버그가 없는지를 한번에 찾을 수 있어서라고 단정 지었다.

하지만 테스트 코드를 짜기 위해 어떻게 테스트를 해야할지 생각해 보는 것 자체로 코드의 결합도를 낮추고 유연성을 높일 수 있다.

애초에 다른 클래스와 긴밀하게 연결된 메서드를 테스트 하려면 커플링 된 클래스 또한 검증을 해야하는 악순환이 반복될 수 있기 때문에 단위 테스트에 집중하는 함수를 만들게 되고 이는 곧바로 직교적인 설계가 가능하게 된다.

> 무엇인가를 테스트 하기 위해서는 그것을 이해해야만 한다.
> 

아리송하게 남아 있는 부분은 테스트 코드를 생각하면서 어느정도 명확하게 정의할 수 있게 된다.

> TDD의 장점 중 하나는 전체 문제를 한 번에 테스트 하나씩 작은 단계로 쪼개서 해결하는 하는 것인데 여러분을 잘못된 길로 인도할 수도 있다.
> 

코딩을 하는 진짜 이유는 잊은 채 어떻게든 작은 문제로 쪼개서 문제를 해결할 수도 있기 때문이라고 한다. 따라서 진짜 내가 해결해야할 문제가 무엇인지 먼저 생각하고 이를 위한 테스트 코드를 짜야 길을 잃지 않고 원하는 테스트 코드를 짤 수 있다.

단위 테스트 코드에서 말하는 단위는 단순히 테스트를 잘개 쪼개는 것이 아니라 풀어야할 문제를 잘 쪼개야한다는 의미로 받아드려야 할 것 같다.

> 테스트할 수 있도록 설계하라
> 

이 또한 이제는 귀에 딱지가 생길 것만 같은 멘트이다..ㅋㅋ 

멘토님이 항상 하는 이야기. 

“테스트 코드를 도저히 짤 수 없다면 설계가 잘못된 것이다.”

Q) 개인적으로 설계를 어떻게 하면 잘할 수 있을까 많이 고민하는데 요번 챕터를 통해서 단위 테스트 코드를 짜면 짤 수록 설계를 잘할 수 있지 않을까 싶었습니다. 혹시 단위 테스트 코드를 짜면 짤 수록 설계가 잘 되어 간다는 경험을 해본 적이 있을까요?

## Topic 42. 속성 기반 테스트

> “계약”은 선행 조건에 맞추어 입력을 넣으면 리턴하는 값이 후행 조건에 맞음을 보장해 주는것이고, “불변식”이란 함수 실행 전후로 어떤 상태에 있어서 불변하는 것을 의미한다. 
이렇게 코드상 계약과 불변식을 뭉뚱그려서 속성이라고 하고 코드에서 속성을 찾아내 테스트를 자동화 하는 것을 속성 기반 테스트라고 한다.
> 

처음 접해보는 개념이라 다소 길게 책에 있는 내용을 가지고 와보았다.

List의 정렬 메소드를 테스트 하기 위해서 List의 속성인 “길이”를 검증하는 것이 가장 대표적인 속성 기반 테스트라고 한다.

단순히 함수의 리턴 값을 검증하는 것이 아니라 해당 클래스가 가지고 있는 속성 값이 무엇인지를 파악하여 함수 전후 값이 동일한지 검증하는 것이 핵심.

실제로 적용할 수 있을지는 잘 감이 잡히지 않지만 타당한 테스트 방법이라는 생각이 든다.

혹시 모르지 않을까? 

검증해야할 함수의 호출 전후로 속성 값이 원하는 상태인지를 파악해서 애상치 못한 피해를 예방할 수도,,?

> 단위 테스트는 테스트에 대해서 생각해 보는 것이 가장 큰 장점이었지만 속성 기반 테스트는 코드를 불변식과 계약의 관점에서 생각해 볼 수 있기 때문에 무엇이 변하지 않아야 하고, 어떤 조건을 만족해야 하는지 생각해 보게 된다.
> 

단위 테스트와 속성 기반 테스트가 확실히 코드를 바라보는 관점이 다른 것 같다.

다만 책에서 나왔듯이 어느 것이 옳고 그름의 문제는 아닌 것 같고 상호 보완적인 개념인 것 같다.

더 나아가 테스트 코드를 짤 때 새로운 관점으로 생각해 볼 수 있어서 많이 유익했던 챕터로 기억이 남을 것 같다.

## Topic 43. 바깥에서는 안전에 주의하라

> 외부에서 코드를 망가뜨려는 시도에 대비해야 한다.
> 

요번 챕터는 보안에 대한 이슈가 나온다.

기본 보안 원칙에 대해서 먼저 살펴보자

> 기본 보안 원칙
1. 공격 표현을 최소화
2. 최소 권한 원칙
3. 안전한 기본값
4. 민감 정보를 암호화
5. 보안 업데이트 적용
> 

하나같이 알아두면 유용한 원칙이만 개인적으로 가장 실용적이라고 생각했던 부분은 암호화에 필요한 키를 환경 변수로 넘겨주는 것이다.

최근에 로그인과 관련된 기능을 만들면서 암호화 기능이 필요했는데 이때 사용한 RSA 알고리즘에서 개인키를 어떻게 관리할지가 이슈였다. 

외부로 뺄 수 있는 방법이 무엇일지 곰곰히 생각해 보았지만 쉽사리 생각나는 방법이 없어서 일단 코드에 박아 놓았는데 매우 불안한 방법이라고 지금도 생각한다.

해서 빌드를 할 때 private 키를 인자로 넘겨주는 방법을 적용하면 해결 할 수 있지 않을까 싶다.

## Topic 44. 이름 짓기

> 프로그래밍에서는 이름이 “모든 것!”이다.
> 

물론 따지고 들어가면 진짜 모든 것이겠냐만은.. 그정도로 중요한 점이라는 것에 누구나 동의할 것이다. 

네이밍만 잘해놔도 진짜 가독성이 2배 이상은 좋아질 수 있다고 믿는다(현재 진행하고 있는 프로젝트에서 Check() 라는 메서드를 만들어 놓는 팀원(또는 팀장)의 코드를 보고 있으면 정말 화딱지가 절로..)

본 챕터에서 단순히 이해하기 쉬운 네이밍을 해야한다에서 멈추는 것이 아니라 타팀에서도 일관적으로 용어를 통일해야한다는 이야기가 나오는데 해당 부분이 신선했다.

누군가에게 있어 order란 주문이겠지만 종교 단체에서는 교단이라는 의미로 해석이 가능하기 때문이다. 이를 방지하기 위해 많은 의사 소통이 필요하고 때로는 용어 사전을 정리하는 것도 좋다고 한다.

> 이름을 잘 지어라. 필요하면 이름을 바꿔라.
> 

처음 명명한 메서드 명이 마음에 들지 않으면 바로바로 변경을 하는 편이라서 매우 와닿았던 팁이다.

Q) 개발자에게 숙명과도 같은 이름 짓기를 잘하는 본인만의 팁을 공유해줄 수 있을까요? 개인적으로 많이 사용하는 팁은 [“**Words used in Source Code”**](http://source-code-wordle.de/)라는 사이트를 애용합니다.