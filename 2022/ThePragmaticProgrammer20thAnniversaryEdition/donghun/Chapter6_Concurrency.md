# 6장. 동시성

## 서문

그 동안 개발 공부를 하면서 가장 높았던 진입 장벽인 동시성 이슈가 등장했다.

처음 코딩을 배웠을 때 C언어로 알고리즘 문제만 2달 가량 풀면서 기본기를 익혔기 때문에 신입 시절 나는 철처히 절차지향에 길들여 있었다. 

따라서 첫 번째로 만났던 허들은 event callback 로직이였고 이어서 비동기 로직 즉, 절차적으로 코드가 동작되지 않는 것에 도저히 이해가 되지 않았다. 

이렇게 짜면 이렇게 동작해라는 수준을 넘고 싶은 마음이 너무 컸기 때문에 운영체제에 대한 이해가 있어야 내부에서 어떻게 동작하는지 알 수 있겠단 판단이 든 이후로 유튜브에 무료로 풀려 있는 대학교 운영체제 강의를 듣기 시작했다. 

총 3분의 다른 교수님의 강의를 들으면서 이제야 겨우 쓰레드에 대한 감이 잡혔고 적어도 쓰레드가 자신의 제어권을 양보해서 다른 코드가 먼저 실행될 수 있도록 하는 로직은 이해가 된 듯 싶다.

해당 챕터를 읽으면서 느낀 점은 적어도 동시성을 깊이 있게 이해하기 위해서(더 나아가 병렬성은 진짜진짜 필수인 것 같아요)는 운영체제에 대한 지식이 필수라고 생각한다.

Q) 비전공자가 컴공 과목에 대해서 알아야하는지 몰라도 괜찮은지에 대한 논의가 종종 이루어지는 것으로 알고 있습니다. 이것에 대한 각자의 생각은 어떤지 궁금합니다!

## Topic 33. 시간적 결합 깨트리기

동시성을 시간과 연관지어서 생각해 볼 수 있는 Topic이다. 

순차적으로 동작하는 코드를 시간적 결합이 있는 상태로 보고 꼭 순차적으로 코드가 동작하는 것이 아니라 동시 다발적으로 코드가 동작할 수 있는 상태가 될 수 있도록 해야한다는 것이 해당 Topic의 골자인 것 같다.

그나마 다행인 점은 Unity는 기존적으로 Event를 기반한 시스템이기 때문에 Unity Life Cycle에서든 UI 이벤트를 통해서든 각 이벤트에서 동작하는 코드를 짜야하기 때문에 자연스럽게 시간적 결합은 낮은 편에 속한 것 같다.

## Topic 34. 공유 상태는 틀린 상태

하나의 리소스를 여러 쓰레드에서 동시다발적으로 접근을 했을 때 발생 할 수 있는 문제점을 짚어주고 있다. 

책에서는 세마포어와 뮤텍스가 언급이 되었지만 C#에서는 lock이라는 키워드를 사용하면 트랜젝션을 구현할 수 있어서 다소 가볍게 리소스 제어가 가능하다. 

다만 언제나 그렇듯 무분별하게 lock을 남발하면 성능에 굉장히 무리가 가기 때문에 lock free 알고리즘을 대용으로 사용한다고 들었다.

개인적으로 접해본 방식은 Job Queue를 활용한 방법이다. 

간단히 요약하면 소켓을 통해 들어온 패킷을 처리하는 Job을 Queue에 저장하는 쓰레드, Queue에 있는 일감(Job)을 꺼내 실제로 처리하는 쓰레드를 각각 고용해서 병렬적으로 처리하는 방식을 사용했었다(물론 해당 방법에서 Job을 관리하는 쪽에서 Enqueue와 Dequeue를 할 때 lock을 걸긴 했다).

적어도 다양한 리소스를 동시적으로(또는 병렬적으로) 접근 할 때 매번 lock을 거는 것보다 들어온 데이터를 처리할 때 각 데이터 별 해야할 일감을 정의하고 이를 병렬적으로 처리할 수 있도록 한 것이 인상 깊었다.

끝으로 이렇게 동시성이 필요한 시점은 결국 병목 현상이 발생했을 때라고 생각한다. 

즉, IO와 같이 시간이 오래 걸리는 작업에 대해서 우선적으로 동시성으로 고려하는 것이 좋을 것 같다.

## Topic 35. 액터와 프로세스

액터라는 생소한 개념이 나오는데 결국 요것도 각각의 액터 객체가 해야할 일감을 동시적으로 처리할 수 있도록 만들어준다는 점에서 Job Queue 사뭇 비슷하게 다가왔다.

하지만 js 문법을 1도 몰라서 당장에 예제로 들어간 코드가 잘 읽히지 않아서 다소 어려웠던 챕터였드아..

## Topic 36. 칠판

칠판 시스템도 먼가 그럴싸하면서 실제로 확 와닿는 개념은 아니었다.

사례가 다소 추상적이라서 그런지 실제로 이걸 활용해서 어떻게 코딩을 해야하는지 다소 난감하긴 했다(== 그냥 어려워서 이해가 안됐,,).