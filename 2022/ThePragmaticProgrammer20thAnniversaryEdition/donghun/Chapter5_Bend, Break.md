# 5장. 구부러지거나 부러지거나

## 서문

미친 듯이 빠르게 변하는 현대 사회 속에서 우리의 코드 또한 언제 어떻게 변화할지 없기 때문에 이에 대응하기 위한 전략이 필요하다고 한다. 따라서 “바꾸기 쉬운 코드”를 작성해야 하고 이를 위한 구체적인 전략들을 해당 챕터에서 살펴볼 예정이다. 

코드를 작성하는데 있어서 만큼은 “바꾸기 쉽게 만들자”라는 맥락이 앞으로도 쭉 이어질 것 같은 느낌이다.

## Topic 28. 결합도 줄이기

> 결합도가 낮은 코드가 바꾸기 쉽다.
> 

결합도가 낮을 수록 코드 수정에 따른 연쇄작용이 덜 일어날 수 있기 때문에 좋다라는 아주 간단하면서도 막상 적용하기는 쉽지 않은 이야기가 나온다.

의존성을 낮추는 것의 필요성은 현실 세계에서도 흔히 찾아볼 수 있는 것 같았다.

최근 애플이 신형 제품을 출시하기 위해 LCD 패널 공급망을 다각화 하려는 움직임을 보면서 의존성을 낮추는 것과 연관지어 생각을 해보게 되었고, 자사 제품을 개발하는 것에 있어서 타사의 협력이 절실히 필요한 순간이 있었는데 그 과정에서도 의존성을 낮추는 것에 대한 필요성을 생각해보게 되었다.

결국은 코드에서든 현실에서든 너무 한 쪽에 의존성을 가지게 되면 문제가 발생할 여지가 커진다는 것은 어김없이 사실인 것 같다. 

> 묻지 말고 말하라
> 

할인을 적용하는 메서드의 사례를 통해서 옳바른 메서드 체이닝을 구성하는 방법에 대해서 이야기를 하고 있다. 단순히 필드를 외부로 오픈하면 안된다고 생각할 법도 했지만 “묻지 말고 말하라”에 담겨 있는 철학을 이해하면 좋을 것 같단 생각이 들었다.

일단 “묻지 말라”는 원칙은 객체의 내부 상태에 어떠한지 직접적으로 알려고 하면 안된다는 뜻인 것 같다. 즉, 하나의 객체가 가지고 있는 속성을 외부에서 직접적으로 접근해서는 안되고 내가 원하는 것을 곧바로 해당 객체에 말한다(요청한다)의 의미로 접근해야 한다.

따라서 

```
고객 → 주문 내역 → 주문 번호로 주문 찾기 → 총 주문 금액 → 할인 적용
```

```
고객 → 주문 번호로 주문 찾기 → 할인 적용
```

이렇게 바로 수정이 가능하게 된다.

**연쇄와 파이프라인**

메서드 체이닝을 통해서 의존성을 낮추는 내용이 나오는데 사실 아직 코드를 작성할 때 이런 메서드 체닝을 고려해서 작성을 잘 안해봐서(사실 못하는 것이지만..) 확 와닿지는 않았다. 

다만, C#에서 제공하는 Linq라는 기능을 활용하는 것과 비슷해 보였다.

**글로벌화의 해악**

전역 데이터에 대한 이야기가 나오는데 그동안 싱글톤에 대해서 워낙 많은 이야기를 다뤘기 때문에 가볍게 생략.

다만, 정말 딱 한가지 기능을 반복적으로 사용하고 있다면 static으로 뽑아서 쓰는 것 정도는 괜찮지 않을까 조심스럽게 생각을 해본다(싱글톤x, 단순히 static 메서드로만 사용).

**상속은 결합을 늘린다.**

구체적인 이유가 있어서 상속을 기피한다기 보다 상속을 써야하는 경우가 있다면 거의 대부분 인터페이스를 잘 활용하면 해결되는 경우가 많이 있는 것 같다.

Q) 여러 클래스에서 중복해서 사용하는 기능이 있다면 이를 어떻게 관리하는 것이 좋을까요? 내부 로직상 반복되는 패턴이 보이는 경우가 많이 있을 때 중복은 되지만 의존성을 고려해서 방치를 하는 것이 좋을지 각자 의견이 궁금합니다!

Q) 코드 변경이 일어났을 때 고통을 받았던 기억이 혹시 있을까요?

## Topic 29. 실세계를 갖고 저글링하기

토픽의 제목과 무슨 상관이 있을까 싶은 이벤트 프로그래밍에 대한 내용이 나온다.

UI와 관련된 이벤트 뿐만 아니라 특정 결과를 알려주는 이벤트 등, 클라이언트 단에서 작업에서 땔래야 땔 수 없는 관계인 것 같다. 이벤트를 잘 활용하면 의존성을 낮출 수 있는 장점 또한 있기 때문에 잘 활용하는 방법을 알아두면 역시나 많은 도움이 될 것 같다는 생각이 들었다.

**유한 상태 기계(FSM)**

이름부터 살번한 개념이 나온다. 그나마 다행인 점은 유니티에서 이런 FSM 개념을 아주 직관적으로 사용하는 곳이 있는데 바로 애니메이션 프로그래밍 쪽이다.

캐릭터가 Idle “상태”일 때, 움직이는 “상태”일 때, 공격하는 “상태”일 때, 죽은 “상태”일 때 등, 하나의 캐릭터가 특정 “상태”로 변경이 되면 곧바로 해당하는 애니메이션을 동작을 시켜줘야 하기 때문에 이러한 FSM 개념이 다소 친숙하게 다가왔다. 

다만, 이벤트를 FSM과 연계해서 생각해볼 수 있다는 것이 신선하게 다가왔었다.

**감시자 패턴**

이벤트를 발생 시키는 쪽과 이벤트를 등록한 쪽으로 나눠서 생각을 해보는 패턴이 나오는데 특정 이벤트가 발생했을 때 해당 이벤트에 영향을 받는 다양한 곳에 메시지를 전달해주기 위한 방법으로 많이 사용하는 패턴이기도 하다.

해당 패턴을 잘 활용하면 객체간의 의존성을 낮출 수도 있어서 좋은데 가령, A 객체에 있는 이벤트에 B 객체에 있는 메서드가 등록을 하면 굳이 A객체는 B객체를 알필요가 전혀 없기 때문에 의존성을 낮춰줄 수가 있다(이때 등록은 A와 B 객체를 알고 있는 C 객체를 통해 하는 방법을 생각해 볼 수 있다).

**반응형 프로그래밍과 스트림 그리고 이벤트**

코드를 짤 때 워낙 절차지향에 익숙한 탓인지 반응형 프로그래밍은 정말 잘 와닿지가 않았다. 

그리고 Unity에서도 이런 반응형 프로그래밍을 지원해 주는 강력한 툴도 존재한다(UniRx).

몇몇 기업에서 UniRx를 사용한 경험이 있는 개발자를 채용하기도 역시 이런 도구는 실제로 써봐야지 확실하게 이해가 될 것 같다.

Q) 각자 사용하고 있는 툴(또는 프레임워크)에서 이런 반응형 프로그래밍을 지원해 주고 있을까요? 

혹시 사용해 본 경험이 있다면 어떤 경위로 사용하게 되었는지 경험담을 나눠주시면 좋을 것 같습니다.

## Topic 30. 변환 프로그래밍

> 모든 프로그램은 데이터를 변환한다. ..중략.. 우리는 이렇게 코드에만 집중하면 핵심을 놓칠 수 있다고 본다. 프로그램이란 입력을 출력으로 바꾸는 것이라는 사고 방식으로 돌아갈 필요가 있다.
> 

해당 챕터에서 나온 코드는 특히 너무 난해해서 코드로 내용 이해는 실패했지만 결국 핵심은 이해가 되었다. 결국 데이터에 집중을 해야한다.

## Topic 31. 상속세

정말 갓난 아기와도 같은 주니어 시절에(지금도 갓난 아기인 것은 거의 매한가지지만.. 무튼) 어떻게든 부모 클래스를 만들기 위해서 애썼던 기억이 있다. 

그래서 자식 클래스의 메서드를 호출하는 것이 아니라 부모를 바라보고 메서드를 호출하는 그 구조가 너무 멋있어 보여서 마냥 위와 같은 방식을 사용했던 시절이 있었다. 

하지만 진짜 시간이 흘러갈 수록 인터페이스의 오묘한 매력에 빠져 들면서 객체가 하고 있는(또는 하게 될) 역할 자체에 집중을 하고 있다. 

현재 수준에서는 인터페이스를 뽑아내는 가장 큰 근거는 “반복성” 여부이지만 조금 더 시간이 흘러 객체지향을 깊게 깨닫게 된다면 다른 차원으로 접근해서 인터페이스를 정의하는 날이 오지 않을까 내심 기대를 하고 있다.

## Topic 32. 설정

최근 NHN에서 진행한 라이브 코딩 인터뷰 중 받았던 피드백과 아주 밀접한 주제라 상당히 흥미롭게 읽었던 챕터이다.

특정 기능 담당하는 UI 시스템을 구축하는 문제였는데, 사용자(개발자)에 의해 추가 요구사항이 들어오게 된다면(ex. UI 버튼을 추가해야 한다면?) 어떻게 대응을 하는 것이 좋을까에 대해서 논의 하는 시간이었다.

나름 확장성 있게 코드를 작성을 해서 enum 값과 간단히 코드 몇 줄을 추가함으로 대응이 가능할 것 같다고 이야기를 드렸지만, 들었던 답변은 그렇다면 다시 빌드 후 재배포를 해야 하는 불편함이 있지 않겠냐라는 답변을 들었다.

즉, 코드 수정에 따른 빌드를 하지 않고 설정 파일을 별도로 제공을 해서 손 쉽게 기능을 추가할 수 있도록 해주면 더 좋겠다라는 피드백을 들었었다.

사용자 입장에서 편리한 방법이 무엇인지를 조금은 깨달을 수 있었던 계기가 되어서 짧게나마 이곳에서도 공유를 합니다.