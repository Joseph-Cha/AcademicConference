# 7장 코딩하는 동안

# Topic 37 파충류의 뇌에 귀 기울이기

> Q. 책에서말하는 파충류의 뇌, 즉, 본능에 따라 행동하여서 잘못된 선택을 한 경험이 일하면서 한번쯤은 있을 것 같은데, 어떤 경험이 있는지, 잘 해결하였는지에 관한 내용을 공유해보자
> 

## 키워드

- 프로토타이핑
- 직감
- 본능, 파충류

## 중요 문장

- 해결책은 일단 본능이 반응하고 있음을 인지하는 것
- 어떤 작업을 앞두고 마음 속에 의심이 계속 남아 있거나 왠지 꺼림칙하다면, 여러분의 경험이 여러분에게 말을 거는 중일지도 모른다. 그 느낌을 따라라
- 여러분은 그저 실수할까 봐 두려운 것일수 있다
- 일단, 하고 있는 일을 멈춰라. 여러분의 뇌가 정리를 좀 할 수 있도록 약간의 시간과 공간을 확보하라.
- 여러분의 뇌에게 여러분이 하려는 일은 별 문제가 없다고 알려줘야 한다.
- 프로토타이핑은 원래 실패한다고 자신에게 상기시켜라
- 가끔은 설계가 왠지 이상하게 느껴질 수도 있고, 어떤 요구사항이 마음을 불편하게 할 수도 있다. 하던 일을 멈추고 그 느낌을 분석하라.

## 내 생각

- 이 장에서 저자는 더 동물적인 본능에 의존한채로 내리는 결정을 경계해야 함을 말하고 있다.
- 내가 현재 처한 어려움이 있다면, 그 어려움이 무엇이고 나는 어떻게 했고, 해결하기위해서 어떻게 해야하는가? 그래서 나의 감정 상태 등은 어떤가? 등등의 내용을 이성적으로 생각해보고 결정내리는게 좋다고 말하는 것으로 보인다
- 개인적으로 파레토의 법칙에 의거하여서, 대부분 80퍼센트의 사람들은 어떤 결정을 내려야 하는 상황에서 이성적인 판단이 아닌, 감정적 본능에 이끌려 결정을 한다고 생각한다. 즉, 우리들 대부분은 책에서 말하는 파충류의 뇌에 의해서 결정을 하게 되고 그 과정에서 후회 하길 반복 한다.
- 회사에서 일 할 때, 무언가 잘 안되는 경험을 해보았을 것이다. 이때 가장 먼저 해야할 것은 쉬면서, 내가 처한 상황과 문제를 객관적으로 파악해서 어떻게 고칠 수 있을지 생각해보고 적용하는 것이라고 생각한다 그러지 않고, 맹목적으로 문제를 풀기위한 감정적 본능으로만 접근한다면, 오히려 터널비전에 빠져서 해결책이 아닌 방향으로 가버릴 수도 있을 것 같다
- 프로토타이핑에 대한 것은 시도와 실패에 대한 두려움을 없앨 목적으로 부담감을 내려주기 위한 방법으로 보인다 나도 자주 쓰는 방법인데, 일부러 실패해도 되는 환경, 마음 가짐을 가지고 무언가를 하려고 하고, 실제 실패해도 실패한 상황에 대한 감정이입이 아닌, 그냥 상황자체를 응 그렇구나 하고 받아들이려 한다 이런 맥락에서 볼 수 있을 것 같다
- 내가 좁은 식견에 벗어나지 못한 채 잘못된 길로 가는 것은 아닌지를 뽀모도로 시간을 기준으로 체크하면서, 내 상태와 문제를 파악하고 문제를 해결하려는 노력이 더더 필요할 것 같다 꼭 일이 아니더라도 내 실생활의 모든 순간에 적용해보자



# Topic 38 우연에 맡기는 프로그래밍

> Q. UI 테스트(셀레니윰 활용) 자동화의 필요성과 경험에 대한 내용을 공유해보자
> 

## 키워드

- 의도적인 프로그래밍
- 우연

## 중요 문장

- 왜 코드가 망가졌는지 프레드가 모르는 까닭은 애초에 코드가 왜 잘 돌아가는지도 몰랐기 때문이다.
- 가정하지 마라, 증명하라
- 우연에 맡기는 프로그래밍을 하지 말라
- 잘되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.
- 더 경험이 적은 프로그래머에게 코드를 상세히 설명할 수 있는가? 그렇지 않다면, 아마 우연에 기대고 있는 것일 터이다.
- 이것이 왜 동작하는지 잘 모른다면 왜 실패하는지도 알 리가 없다.
- 계획을 세우고 그것을 바탕으로 진행하라.
- 가정을 기록으로 남겨라
- 코드뿐 아니라 여러분이 세운 가정도 테스트해 보아야 한다. 어떤 일이든 추측만 하지 말고실제로 시험해 보라.

## 내 생각

- 기도 주도 개발 이라는 것이 있다. 내가 작성한 코드가 버그 없이 무사하게 잘 돌게 하기 위해서 열심히 기도하는 것을 말한다. 우연에 맡기는 프로그래밍도 이것과 별반 다를게 없다.
- 하지만, 웃기게도 이런 경우가 나를 포함해서도 매우 많다는 것이다. 부끄러운 얘기지만, 내가 사용하고 있는 언어와 프레임워크, DB에 대해서 나는 모든 내용을 알지 못한다 내가 쓰는 도구에 대해서는 최소한 동작원리에 대해서는 알고 써야한다고 생각한다. 물론 일을 하다보면, 챙기지 못한 떄가 훨씬 많지만, 내가 쓰는 도구구에 대해서 완벽하게 이해하고 써야 한다는 것에는 백퍼센트 동의한다
- 기도는 현실적인 해결책이 아니다 그저 우연에 맡길 뿐이다
- 이 책의 내용중에 `이것이 왜 동작하는지 잘 모른다면 왜 실패하는지도 알 리가 없다` 문장이 너무 와닿았다. 코드 개발할 때, 동작방식에 대한 완벽한 이해가 전제되어야 한다는 말이다. 너무나도 당연한 말이다 쓰는 당시 모르고 쓴다면, 적어도 쓰고 나서라도 알려는 노력은 필요하다
- `여러분이 세운 가정도 테스트해 보아야 한다` 와 관련해서는 개발자 QA를 더 확실하고 잘 할 수 있는 방법을 고민해봐야겠다는 생각이 들었다. 나부터도 개발자QA에 대해서 진행은 하고 있지만 모든 경우의 수를 꼼꼼하게 확인은 해보지 못하고 있고 어느정도 가정과 전제를 두고 테스트하는 경우도 꽤된다 이는 반드시 고쳐야할 점이고, 어느정도 기도에 의존함을 말해준다 직접 눈으로 동작하는 소프트웨어로 확인을 해야만 한다


# Topic 39 알고리즘의 속도

> Q. 특정 기능에 대한 성능테스트 및 프로파일링을 평소 업무에서 어떻게 진행하는지 공유해보자
> 

## 키워드

- 입력 크기
- 빅오 표기법
- 코드 프로파일러
- 성급한 최적화

## 중요 내용

- 알고리즘이 사용하는 자원, 곧 시간, 프로세서, 메모리 등을 추정하는 것이다.
- 입력 값으로 얼마나 큰 숫자가 올 수 있는지 스스로 에게 물어봐야 한다
- 커다란 수가 들어 왔을 경우 수행 시간이나 메모리 소모에 어떤 영향을 미칠지 생각해 보는 것이 좋다.
- 성급환 최적화를 조심하라

## 내 생각

- 흔히 내가 알고 있는 추정은 업무에 대한 추정만 이해하고 있었는데, 책에서 알고리즘에 대한 추정도 언급하여서 뭔가 새롭게 와닿았다 동시에 그동안 나는 알고리즘에 대한 추정은 전혀 고려하지 않고 있었음을 깨닫게 되었다
- 알고리즘 문제를 풀 때, 큰 수에 대해서 알고리즘 최적화 하는 문제를 자주 틀리는 편인데, 큰 수에 대한 고려 없이 단순히 문제를 푸는  습관 때문에 발생한다는 것을 자각할 수 있었다 반성하고 항상 알고리즘에 대한 추정이 필요함을 느끼고 실천 해야만한다
- 이 파트를 읽으면서, 알고리즘 공부를 더 열심히 해야겠다는 동기부여를 얻었다
- 그동안 개발하면서, 내가 작성한 코드의 프로파일링 하는 것에는 크게 관심이 없었으나, 내가 작성하는 모든 코드에 프로파일링 하는 습관을 들이면 좋을 것 같다는 생각이 들었다
- 내 생각에 컴퓨터 엔지니어링이 매력있는 이유는 절대적인 것이 존재하지 않기 때문이다. 모든 것에 트레이드 오프가 있다. 마찬가지로 알고리즘의 세계에서도 항상 모든 상황을 커버할 수 있는 알고리즘 같은 것은 존재하지 않는다 우리는 개발자로써 각 상황에 맞게 가장 적절한 알고리즘을 떠올릴 수 있어야 하고 적용할 수 있어야 한다 아직 까지 나는 이런 역량이 부족하다고 느껴진다 알고리즘에 대한 배경지식을 더 넓혀야 함을 느꼈고, 동기부여도 얻을 수 있었다

# Topic 40 리팩터링

> Q. 평소 업무 시, 리팩토링 주기가 어떻게 되는지 공유해보자, 너무 짧거나 너무 길어서 생긴 문제는 없는지 추가로 공유해보자
> 

## 키워드

- 리팩토링

## 중요 내용

- 소프트웨어 개발은 건축보다 정원 가꾸기에 더 가깝다
- 주저하지 말고 변경하라.
- 탄탄한 회귀 테스트를 유지하는 것이야말로 안전한 리팩터링의 비결이라는 것이다.

## 내 생각

- 리팩토링에 대해서 깊게 이해하지 못하고 오이해 하고 있는 경우를 많이 보았다. 예를들면, 프로젝트 마지막에 리팩토링을 따로 하는 시간을 두는 것이다 혹은 리팩토링 한다는 커밋에 의도적으로 테스트가 수정되거나 추가되는 경우도 보았다. 이 책에서는 리팩토링이 필요한 이유와 그 개념에 대해서 명확하게 정의를 해준다 특히나 주저하지 말고 변경하라 라는 말은 팀에도 적극 공유 하고 이 가치에 대해서 이해한 상태로 일을 하고 싶다는 생각이 들었다
- 만약에 리팩터링 하기가 두렵거나 꺼려진다면, 아마도 테스트가 충분하지 않아서 무슨 문제가 벌어질지 상상 할 수 없기 때문일 것 같다. 이런 경우가 아닌 이상, 모든 요구사항을 충족하는 테스트를 언제든 돌려볼 수 있는 환경에서 리팩토링을 못할 이유가 없기 때문이다. 책에서 마틴 파울러가 말한대로, 탄탄한 회귀 테스트를 항상 유지할 수 있도록 반드시 필요한 테스트에 대해서는 테스트를 꼼꼼하게 작성을 하자

# Topic 41 테스트로 코딩하기

> Q1. 개인적으로는 private method에 대한 테스트 작성은 반대 하고, 굳이 작성할 필요가 없다고 생각하는 편이다. 오히려 쓸데없는 테스트가 추가되어서 중요한 테스트가 잘 드러나지 않게 방해한다고 생각한다 이에 대해서 어떻게 생각하는지 공유해보자

Q2. 테스트 커버리지 측정은 숫자 100에 집착하는게 아닌, 내가 테스트하고 싶은 중요한 부분이 커버되고 있는지 확인하는 용도로 활용하는게 맞다고 생각하는 편이다 테스트 커버리지를 업무에서 어떻게 활용하고 있는지 공유해보자
> 

## 키워드

- 테스트

## 중요 내용

- 테스트는 버그를 찾기 위한 것이 아니다
- 테스트의 주요한 이득이 테스트를 실행할 때가 아니라 테스트에 대해 생각하고, 테스트를 작성할 때 생긴다고 믿는다
- 사용자인 것처럼 메서드를 외부의 시선으로 보게 되었다.
- 코딩을 시작하기 전에 경계 조건의 테스트와 경계조건에서 어떻게 동작해야 하는지를 먼저 생각해본다면, 아마 함수를 단순하게 만드는 코드 패턴을 찾을 수 있을 것이다.
- 어떻게든 TDD를 실천하라 하지만 도중에 이따금 멈추어 큰 그림을 살피는 것을 잊지말라.
- 테스트는 프로그래밍의 일부다. 다른 사람이나 다른 부서에 떠넘길 수 있는 것이 아니다. 테스트, 설계, 코딩, 이 모든 것이 프로그래밍 이다.
- 테스트 코드를 다른 제품 코드와 마찬가지로 다뤄라. 결합도를 낮추고, 깨끗하고 견고하게 유지하라

## 내 생각

- 나는 이전까지 테스트를 만들 때, 모든 요구사항에 대해서 꼼꼼하게 회귀테스트를 만들어야 한다는 생각으로 테스트 코드를 작성해왔다. 이 파트를 읽으면서, 단순히 테스트 코드가 존재하는 것 이상으로 테스트를 작성하기 위해서 고민하고 생각하는 과정 까지도 테스트를 작성하는 가치에 해당한다는 것을 이해할 수 있어서 좋았다.
- 테스트 코드가 내 백엔드 API를 호출하는 또다른 클라이언트라는 생각은 그동안 따로 해보지 않은 것 같다 클라이언트에서 발생할 수 있는 다양한 경우를 미리 예측 하거나, 계약에 명시하여서 테스트로 구현하는 식으로 작업해볼 수 있을 것 같다. 이럴 경우에 클라이언트(대개는 앱, 웹)와 협업 과정에서 계약을 더 명시적으로 정의한다던지 하여서, 발생할 수 있는 상황에 대해서 더 잘 통제가 가능할 것으로 보인다
- 모든 일을 할 때, 무의식적으로 우리는 어떻게 할지 계획을 세운다. MBTI가 P 인 사람이 본인은 계획 세우는걸 싫어하고, 세우지 않는다고 하더라도 우리는 자연스레 어떤 일을 하기전에 어떻게 진행할지 머릿속에서 생각을 하고 실천하게 된다 이에 반해서 코드를 작성할 때는 계획에 대해서 무관심하고 신경을 안쓰는 경우가 많은듯 하다. 일단 코드 부터 쓰고 보는 것인데, 빨리 가려다가 돌고돌아 더 늦어지게 되는 결과를 초래한다고 생각한다 테스트 자체를 계획을 작성하는 단계로 생각하고, 일종의 TODO 리스트로 생각해보고 작성해보면 많은 도움이 될것이라 생각된다
- 책에서 나오는 실천사항들 중 거의 다 지킨다고 생각되면서 잘 못하고 있는 것은 테스트 코드의 품질을 유지하는 것이다. 부끄럽지만 테스트 코드에 대해서는 구현 코드 처럼 리뷰 및 리팩토링을 하고 있지 못하고 있다 이번을 계기로 테스트 코드들의 품질도 유지할 수 있게끔 해야겠다
- 테스트는 QA가 해야하는게 아니라, 개발자가 직접해야한다고 생각한다. QA의 역할은 happy path와 unhappy path에 대한 테스트가 아닌, unexpected behavior 에 대한 테스트를 수행하고 검증하는 역할이라고 생각한다. 나의 이런 생각에 대부분의 사람들이 동의하지 않는다 심지어 QA 분들도 동의하지 않는다 아마도 너무나도 오랫동안 테스트는 QA가 맡아서 해야한다는 편견이 이어졌기 때문 일것 같다. 그럼에도 불구하고, 나는 expected behavior(happy path, unhappy path)에 대해서는 개발자가 테스트코드와 직접 메뉴얼 테스트로 까지 확인해야한다고 생각한다 책에서 말한대로 개발자는 코드만 짜는 사람이 아니라 제품을 만드는 사람으로써, 본인이 만든 제품의 개밥까지도 먹어야 하기 때문이다



# Topic 42 속성 기반 테스트

> 업무에서 속성 기반 테스트를 적극적으로 하고 있는지 궁금합니다. 하고있다면 어떻게 하고 있었는지, 그렇지 않다면, 어디에 쓰면 좋을 것 같은지 같이 이야기해 보아요
> 

## 키워드

- 계약, 불변식, 속성
- 속성기반테스트

## 중요 내용

- 코드에 존재하는 계약과 불변식을 뭉뚱그려서 속성 이라고 부른다. 코드에서 속성을 찾아내서 테스트 자동화에 사용할 수 있는데, 이것을 속성 기반 테스트라 한다.
- 속성 기반 테스트가 강력한 까닭은 그저 입력을 생성하는 규칙과 출력을 검증하는 단정문만 설정한 채 제멋대로 작동하도록 놔두기 때문이다.
- 속성 기반 테스트가 실패했다면 테스트 함수가 어떤 매개 변수를 사용했는지 알아낸 다음 그 값을 이용하여 별도의 단위테스트를 정식으로 추가하는 것이 좋다.
- 속성 기반 테스트는 여러분이 코드를 불변식과 계약이라는 관점으로 바라보게 한다. 여러분은 무엇이 변하지 않아야 하고, 어떤 조건을 만족해야 하는지 생각하게 된다.

## 내 생각

- 속성 기반 테스트는 이전부터 컨퍼런스 발표로도 자주 올라왔었던 주제로 눈에는 익는 주제이다. 그러나 이것에 어떤 장점이 있고, 어떻게 활용할 수 있는지에 대해서는 관심밖이 였는데, 처음에 소제목을 보았을 때, 이게 얼마나 중요하면 실용주의 프로그래머 Topic 중 1개로 있겠냐 라는 생각이 들면서, 관심깊게 읽어 볼 수 있었다
- 책 앞부분에서 인상 깊었던 것은, 속성들의 집합을 정의했을 때, 테스트가 자동으로 given에 해당하는 데이터들을 랜덤으로 혹은 주어진 조건대로 만들어주는 부분이였다. 단위테스트를 할 때, 모든 경우의 given 데이터를 커버하려고 노력 하면서도, 경우의수가 많은 경우에 놓치는 경우도 있는데, 이럴 때 사용하면 딱 일 것 같다는 생각이 들었다.
- pytest를 이용해서 비슷하게 나마 테스트를 작성할 수 있긴 하지만, 그래도 속성테스트라고 하는 것의 나름의 가치가 따로 있을 것이라는 생각이들었고, 따로 조사해서 내 프로젝트에 적용할 수 있을지 살펴봐야겠다는 생각이 들었다
- 속성 기반 테스트를 통해서 불변식과 계약을 통해서 설계에도 도움이 될 수 있음을 알 수 있게 되었다. 사실 꼭 속성 기반 테스트가 아니더라도 불변식과 계약에 대해서 미리 고민하는 것 자체로 설계에 도움이 될 수 있다고 생각하는데, 글의 맥락 상 속성 기반 테스트를 고민하는 과정에 포함 된다고 생각해서 말한 것으로 보인다 어찌되었든 속성 기반 테스트를 어디에 활용하면 좋을지 고민해보고 적용해보자

# Topic 43 바깥에서는 안전에 주의하라

> `책의 내용 중 인증이 없는 서비스는 공격 매개체다` 부분에서, JWT쓴다는 가정하에, 아직 로그인을 하기 전이라 토큰을 부여받지 않은 사용자가 인증과 관련되지 않은 API를 호춣할 수도 있을 것 같은데, 이런 것 까지 다막아야 할까요? 그렇다면 로그인 이전 유저의 인증은 대개 어떻게 처리하나요? 경험을 공유해주시면 좋을것 같습니다
> 

## 키워드

- 외부 데이터
- 최소 권한

## 중요 내용

- 다음으로 해야하는 일은 코드가 잘못될 수 있는 경우를 찾아보고, 각 경우에 대한 단위 테스트를 추가하는 것이다.
- 복잡한 코드는 예상 외의 부작용이 일어날 확률을 높이고, 결과적으로 공격 표면을 넓힌다
- 외부의 데이터를 절대 신뢰하지 말라
- 최소한의 권한만을 꼭 필요한 시간만큼만 제일 짧게 부여하라
- 암호화는 직접 하지 않는 편이 낫다

## 내 생각

- 내가 학생 시절 처음 웹개발을 시작했을 때, 외부 클라이언트로 부터 받은 POST method의 request body를 왜 validation 체크해야하는지 이해하지 못하였었다. 바깥에서 부터 온 데이터를 항상 신뢰해도 되는가? 에 대한 인식이 전혀 없었기 때문이다. 현재는 이 맥락을 이해하고 있는 입장에서 이 장의 내용은 매우 좋았고, 혹시 예전의 나처럼 이런 개념에 대해서 잘 모르고 있는 사람이 있다면 이 파트만 따로 읽어보라고 권해보고 싶다
- 아쉽게도 책에서 말한 나머지90% 를 고려하지 않는 경우를 많이 보았다 대표적으로 개발자가 manual로 본인의 코드가 돌아가긴하는지 직접 테스트 해보지 않는 것이다. 앞장에서도 나왔다시피 나는 개발자가 본인 기능에 대한 기본적인 QA는 해야만 한다고 생각한다. QA는 QE분들이 하는게 아니라, 기본적인 happy path, unhappy path에 대해서 내가 의도대로 동작하는지 확인하는 절차가 반드시 필요하다고 생각한다. 그럼에도 불구하고, 그렇지 않은 경우가 더 많다보니 이런걸로 버그가 발생하고, 다른 직권의 QA 난이도가 상승하는게 아닐까? 라는 생각이든다
- 개인적으로 복잡한 코드가 정말로 많은 실수를 유발하는 코드스멜이라고 생각한다. 대개 이런 것들은 내 짧은 경험상 요구하는 비즈니스 로직이 복잡한 것도 있지만, 그것보다 책임에 맞게 잘게 쪼개지 못하고 한번에 처리하려다 보니 발생하는 문제라고 생각한다 복잡하다 싶으면 내가 뭔가 잘 못한게 아닐까? 라는 의심을 가지자
- `최소한의 권한만을 꼭 필요한 시간만큼만 제일 짧게 부여하라` 이것 매우 중요한데, 놀랍게도 안지키는 경우도 굉장히 보았다 그냥 일단.. root
- `암호화는 직접 하지 않는 편이 낫다` 바퀴를 다시 만들지 말자 나보다 머리좋은 사람들이 여러명 모여서 만든 것들을 신뢰하고 사용하자

# Topic 44 이름 짓기

## 키워드

- ETC 위반

## 중요 내용

- 프로그래밍에서는 이름이 “모든 것"이다
- 이름을 지을 때는 여러분이 표현하고 싶은 것을 더 명확하게 다듬기 위해 끊임없이 노력해야 한다.
- 모든 사람이 각 단어의 뜻을 알고 일관성 있게 사용해야한다.

## 내 생각

- 이름 짓기는 너무 중요해서 더이상 말할 것이 없다 최근에 리팩토링 책을 읽고 있는데, 여기서도 내용의 반이 이름을 잘 지으라는 얘기이다 너무 공감한다.
- 이름과 관련된 깨진 창문에 많이 찔려보았다 착각해서 버그도 내보고, 장애도 맞아보고.. 코드를 도저히 읽지 못할 수준인.. 그러다보니 나 자체로 이름에 많이 집착하는 편이다. 책에서 나온대로, 제너럴한 단어 안쓰려고하고 좀 길어져도 가능하다면 길게 붙여서라도 의미단위로 코드가 읽힐 수 있도록 노력하는 편이다
- 개인적으로 i,j,k 에 대해서는 동의하지 못한다. production 코드에서는 써선 안된다고 생각한다. C언어를 배워본 사람이 아닌 사람은 코드 맥락을 이해할 수 없기 떄문이다
- 괜히 DDD 에서 유비쿼터스 랭귀지를 언급하는게 아니다. 기본적으로 개발자 이기전에 한 사람으로 팀원끼리 의사소통이 잘되어야 한다고 생각한다
- 잘못된 이름은 언제든 깨진 창문에 찔리듯 하여 피가 날 수 있다 그때그때 고쳐주자