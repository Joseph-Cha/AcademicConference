# 7장 코딩하는 동안

# Topic 37 파충류의 뇌에 귀 기울이기

> Q. 책에서말하는 파충류의 뇌, 즉, 본능에 따라 행동하여서 잘못된 선택을 한 경험이 일하면서 한번쯤은 있을 것 같은데, 어떤 경험이 있는지, 잘 해결하였는지에 관한 내용을 공유해보자
> 

## 키워드

- 프로토타이핑
- 직감
- 본능, 파충류

## 중요 문장

- 해결책은 일단 본능이 반응하고 있음을 인지하는 것
- 어떤 작업을 앞두고 마음 속에 의심이 계속 남아 있거나 왠지 꺼림칙하다면, 여러분의 경험이 여러분에게 말을 거는 중일지도 모른다. 그 느낌을 따라라
- 여러분은 그저 실수할까 봐 두려운 것일수 있다
- 일단, 하고 있는 일을 멈춰라. 여러분의 뇌가 정리를 좀 할 수 있도록 약간의 시간과 공간을 확보하라.
- 여러분의 뇌에게 여러분이 하려는 일은 별 문제가 없다고 알려줘야 한다.
- 프로토타이핑은 원래 실패한다고 자신에게 상기시켜라
- 가끔은 설계가 왠지 이상하게 느껴질 수도 있고, 어떤 요구사항이 마음을 불편하게 할 수도 있다. 하던 일을 멈추고 그 느낌을 분석하라.

## 내 생각

- 이 장에서 저자는 더 동물적인 본능에 의존한채로 내리는 결정을 경계해야 함을 말하고 있다.
- 내가 현재 처한 어려움이 있다면, 그 어려움이 무엇이고 나는 어떻게 했고, 해결하기위해서 어떻게 해야하는가? 그래서 나의 감정 상태 등은 어떤가? 등등의 내용을 이성적으로 생각해보고 결정내리는게 좋다고 말하는 것으로 보인다
- 개인적으로 파레토의 법칙에 의거하여서, 대부분 80퍼센트의 사람들은 어떤 결정을 내려야 하는 상황에서 이성적인 판단이 아닌, 감정적 본능에 이끌려 결정을 한다고 생각한다. 즉, 우리들 대부분은 책에서 말하는 파충류의 뇌에 의해서 결정을 하게 되고 그 과정에서 후회 하길 반복 한다.
- 회사에서 일 할 때, 무언가 잘 안되는 경험을 해보았을 것이다. 이때 가장 먼저 해야할 것은 쉬면서, 내가 처한 상황과 문제를 객관적으로 파악해서 어떻게 고칠 수 있을지 생각해보고 적용하는 것이라고 생각한다 그러지 않고, 맹목적으로 문제를 풀기위한 감정적 본능으로만 접근한다면, 오히려 터널비전에 빠져서 해결책이 아닌 방향으로 가버릴 수도 있을 것 같다
- 프로토타이핑에 대한 것은 시도와 실패에 대한 두려움을 없앨 목적으로 부담감을 내려주기 위한 방법으로 보인다 나도 자주 쓰는 방법인데, 일부러 실패해도 되는 환경, 마음 가짐을 가지고 무언가를 하려고 하고, 실제 실패해도 실패한 상황에 대한 감정이입이 아닌, 그냥 상황자체를 응 그렇구나 하고 받아들이려 한다 이런 맥락에서 볼 수 있을 것 같다
- 내가 좁은 식견에 벗어나지 못한 채 잘못된 길로 가는 것은 아닌지를 뽀모도로 시간을 기준으로 체크하면서, 내 상태와 문제를 파악하고 문제를 해결하려는 노력이 더더 필요할 것 같다 꼭 일이 아니더라도 내 실생활의 모든 순간에 적용해보자



# Topic 38 우연에 맡기는 프로그래밍

> Q. UI 테스트(셀레니윰 활용) 자동화의 필요성과 경험에 대한 내용을 공유해보자
> 

## 키워드

- 의도적인 프로그래밍
- 우연

## 중요 문장

- 왜 코드가 망가졌는지 프레드가 모르는 까닭은 애초에 코드가 왜 잘 돌아가는지도 몰랐기 때문이다.
- 가정하지 마라, 증명하라
- 우연에 맡기는 프로그래밍을 하지 말라
- 잘되는 듯한 답을 찾는 것과 올바른 답을 찾는 것은 다르다.
- 더 경험이 적은 프로그래머에게 코드를 상세히 설명할 수 있는가? 그렇지 않다면, 아마 우연에 기대고 있는 것일 터이다.
- 이것이 왜 동작하는지 잘 모른다면 왜 실패하는지도 알 리가 없다.
- 계획을 세우고 그것을 바탕으로 진행하라.
- 가정을 기록으로 남겨라
- 코드뿐 아니라 여러분이 세운 가정도 테스트해 보아야 한다. 어떤 일이든 추측만 하지 말고실제로 시험해 보라.

## 내 생각

- 기도 주도 개발 이라는 것이 있다. 내가 작성한 코드가 버그 없이 무사하게 잘 돌게 하기 위해서 열심히 기도하는 것을 말한다. 우연에 맡기는 프로그래밍도 이것과 별반 다를게 없다.
- 하지만, 웃기게도 이런 경우가 나를 포함해서도 매우 많다는 것이다. 부끄러운 얘기지만, 내가 사용하고 있는 언어와 프레임워크, DB에 대해서 나는 모든 내용을 알지 못한다 내가 쓰는 도구에 대해서는 최소한 동작원리에 대해서는 알고 써야한다고 생각한다. 물론 일을 하다보면, 챙기지 못한 떄가 훨씬 많지만, 내가 쓰는 도구구에 대해서 완벽하게 이해하고 써야 한다는 것에는 백퍼센트 동의한다
- 기도는 현실적인 해결책이 아니다 그저 우연에 맡길 뿐이다
- 이 책의 내용중에 `이것이 왜 동작하는지 잘 모른다면 왜 실패하는지도 알 리가 없다` 문장이 너무 와닿았다. 코드 개발할 때, 동작방식에 대한 완벽한 이해가 전제되어야 한다는 말이다. 너무나도 당연한 말이다 쓰는 당시 모르고 쓴다면, 적어도 쓰고 나서라도 알려는 노력은 필요하다
- `여러분이 세운 가정도 테스트해 보아야 한다` 와 관련해서는 개발자 QA를 더 확실하고 잘 할 수 있는 방법을 고민해봐야겠다는 생각이 들었다. 나부터도 개발자QA에 대해서 진행은 하고 있지만 모든 경우의 수를 꼼꼼하게 확인은 해보지 못하고 있고 어느정도 가정과 전제를 두고 테스트하는 경우도 꽤된다 이는 반드시 고쳐야할 점이고, 어느정도 기도에 의존함을 말해준다 직접 눈으로 동작하는 소프트웨어로 확인을 해야만 한다


# Topic 39 알고리즘의 속도

> Q. 특정 기능에 대한 성능테스트 및 프로파일링을 평소 업무에서 어떻게 진행하는지 공유해보자
> 

## 키워드

- 입력 크기
- 빅오 표기법
- 코드 프로파일러
- 성급한 최적화

## 중요 내용

- 알고리즘이 사용하는 자원, 곧 시간, 프로세서, 메모리 등을 추정하는 것이다.
- 입력 값으로 얼마나 큰 숫자가 올 수 있는지 스스로 에게 물어봐야 한다
- 커다란 수가 들어 왔을 경우 수행 시간이나 메모리 소모에 어떤 영향을 미칠지 생각해 보는 것이 좋다.
- 성급환 최적화를 조심하라

## 내 생각

- 흔히 내가 알고 있는 추정은 업무에 대한 추정만 이해하고 있었는데, 책에서 알고리즘에 대한 추정도 언급하여서 뭔가 새롭게 와닿았다 동시에 그동안 나는 알고리즘에 대한 추정은 전혀 고려하지 않고 있었음을 깨닫게 되었다
- 알고리즘 문제를 풀 때, 큰 수에 대해서 알고리즘 최적화 하는 문제를 자주 틀리는 편인데, 큰 수에 대한 고려 없이 단순히 문제를 푸는  습관 때문에 발생한다는 것을 자각할 수 있었다 반성하고 항상 알고리즘에 대한 추정이 필요함을 느끼고 실천 해야만한다
- 이 파트를 읽으면서, 알고리즘 공부를 더 열심히 해야겠다는 동기부여를 얻었다
- 그동안 개발하면서, 내가 작성한 코드의 프로파일링 하는 것에는 크게 관심이 없었으나, 내가 작성하는 모든 코드에 프로파일링 하는 습관을 들이면 좋을 것 같다는 생각이 들었다
- 내 생각에 컴퓨터 엔지니어링이 매력있는 이유는 절대적인 것이 존재하지 않기 때문이다. 모든 것에 트레이드 오프가 있다. 마찬가지로 알고리즘의 세계에서도 항상 모든 상황을 커버할 수 있는 알고리즘 같은 것은 존재하지 않는다 우리는 개발자로써 각 상황에 맞게 가장 적절한 알고리즘을 떠올릴 수 있어야 하고 적용할 수 있어야 한다 아직 까지 나는 이런 역량이 부족하다고 느껴진다 알고리즘에 대한 배경지식을 더 넓혀야 함을 느꼈고, 동기부여도 얻을 수 있었다

# Topic 40 리팩터링

> Q. 평소 업무 시, 리팩토링 주기가 어떻게 되는지 공유해보자, 너무 짧거나 너무 길어서 생긴 문제는 없는지 추가로 공유해보자
> 

## 키워드

- 리팩토링

## 중요 내용

- 소프트웨어 개발은 건축보다 정원 가꾸기에 더 가깝다
- 주저하지 말고 변경하라.
- 탄탄한 회귀 테스트를 유지하는 것이야말로 안전한 리팩터링의 비결이라는 것이다.

## 내 생각

- 리팩토링에 대해서 깊게 이해하지 못하고 오이해 하고 있는 경우를 많이 보았다. 예를들면, 프로젝트 마지막에 리팩토링을 따로 하는 시간을 두는 것이다 혹은 리팩토링 한다는 커밋에 의도적으로 테스트가 수정되거나 추가되는 경우도 보았다. 이 책에서는 리팩토링이 필요한 이유와 그 개념에 대해서 명확하게 정의를 해준다 특히나 주저하지 말고 변경하라 라는 말은 팀에도 적극 공유 하고 이 가치에 대해서 이해한 상태로 일을 하고 싶다는 생각이 들었다
- 만약에 리팩터링 하기가 두렵거나 꺼려진다면, 아마도 테스트가 충분하지 않아서 무슨 문제가 벌어질지 상상 할 수 없기 때문일 것 같다. 이런 경우가 아닌 이상, 모든 요구사항을 충족하는 테스트를 언제든 돌려볼 수 있는 환경에서 리팩토링을 못할 이유가 없기 때문이다. 책에서 마틴 파울러가 말한대로, 탄탄한 회귀 테스트를 항상 유지할 수 있도록 반드시 필요한 테스트에 대해서는 테스트를 꼼꼼하게 작성을 하자

# Topic 41 테스트로 코딩하기

> Q1. 개인적으로는 private method에 대한 테스트 작성은 반대 하고, 굳이 작성할 필요가 없다고 생각하는 편이다. 오히려 쓸데없는 테스트가 추가되어서 중요한 테스트가 잘 드러나지 않게 방해한다고 생각한다 이에 대해서 어떻게 생각하는지 공유해보자

Q2. 테스트 커버리지 측정은 숫자 100에 집착하는게 아닌, 내가 테스트하고 싶은 중요한 부분이 커버되고 있는지 확인하는 용도로 활용하는게 맞다고 생각하는 편이다 테스트 커버리지를 업무에서 어떻게 활용하고 있는지 공유해보자
> 

## 키워드

- 테스트

## 중요 내용

- 테스트는 버그를 찾기 위한 것이 아니다
- 테스트의 주요한 이득이 테스트를 실행할 때가 아니라 테스트에 대해 생각하고, 테스트를 작성할 때 생긴다고 믿는다
- 사용자인 것처럼 메서드를 외부의 시선으로 보게 되었다.
- 코딩을 시작하기 전에 경계 조건의 테스트와 경계조건에서 어떻게 동작해야 하는지를 먼저 생각해본다면, 아마 함수를 단순하게 만드는 코드 패턴을 찾을 수 있을 것이다.
- 어떻게든 TDD를 실천하라 하지만 도중에 이따금 멈추어 큰 그림을 살피는 것을 잊지말라.
- 테스트는 프로그래밍의 일부다. 다른 사람이나 다른 부서에 떠넘길 수 있는 것이 아니다. 테스트, 설계, 코딩, 이 모든 것이 프로그래밍 이다.
- 테스트 코드를 다른 제품 코드와 마찬가지로 다뤄라. 결합도를 낮추고, 깨끗하고 견고하게 유지하라

## 내 생각

- 나는 이전까지 테스트를 만들 때, 모든 요구사항에 대해서 꼼꼼하게 회귀테스트를 만들어야 한다는 생각으로 테스트 코드를 작성해왔다. 이 파트를 읽으면서, 단순히 테스트 코드가 존재하는 것 이상으로 테스트를 작성하기 위해서 고민하고 생각하는 과정 까지도 테스트를 작성하는 가치에 해당한다는 것을 이해할 수 있어서 좋았다.
- 테스트 코드가 내 백엔드 API를 호출하는 또다른 클라이언트라는 생각은 그동안 따로 해보지 않은 것 같다 클라이언트에서 발생할 수 있는 다양한 경우를 미리 예측 하거나, 계약에 명시하여서 테스트로 구현하는 식으로 작업해볼 수 있을 것 같다. 이럴 경우에 클라이언트(대개는 앱, 웹)와 협업 과정에서 계약을 더 명시적으로 정의한다던지 하여서, 발생할 수 있는 상황에 대해서 더 잘 통제가 가능할 것으로 보인다
- 모든 일을 할 때, 무의식적으로 우리는 어떻게 할지 계획을 세운다. MBTI가 P 인 사람이 본인은 계획 세우는걸 싫어하고, 세우지 않는다고 하더라도 우리는 자연스레 어떤 일을 하기전에 어떻게 진행할지 머릿속에서 생각을 하고 실천하게 된다 이에 반해서 코드를 작성할 때는 계획에 대해서 무관심하고 신경을 안쓰는 경우가 많은듯 하다. 일단 코드 부터 쓰고 보는 것인데, 빨리 가려다가 돌고돌아 더 늦어지게 되는 결과를 초래한다고 생각한다 테스트 자체를 계획을 작성하는 단계로 생각하고, 일종의 TODO 리스트로 생각해보고 작성해보면 많은 도움이 될것이라 생각된다
- 책에서 나오는 실천사항들 중 거의 다 지킨다고 생각되면서 잘 못하고 있는 것은 테스트 코드의 품질을 유지하는 것이다. 부끄럽지만 테스트 코드에 대해서는 구현 코드 처럼 리뷰 및 리팩토링을 하고 있지 못하고 있다 이번을 계기로 테스트 코드들의 품질도 유지할 수 있게끔 해야겠다
- 테스트는 QA가 해야하는게 아니라, 개발자가 직접해야한다고 생각한다. QA의 역할은 happy path와 unhappy path에 대한 테스트가 아닌, unexpected behavior 에 대한 테스트를 수행하고 검증하는 역할이라고 생각한다. 나의 이런 생각에 대부분의 사람들이 동의하지 않는다 심지어 QA 분들도 동의하지 않는다 아마도 너무나도 오랫동안 테스트는 QA가 맡아서 해야한다는 편견이 이어졌기 때문 일것 같다. 그럼에도 불구하고, 나는 expected behavior(happy path, unhappy path)에 대해서는 개발자가 테스트코드와 직접 메뉴얼 테스트로 까지 확인해야한다고 생각한다 책에서 말한대로 개발자는 코드만 짜는 사람이 아니라 제품을 만드는 사람으로써, 본인이 만든 제품의 개밥까지도 먹어야 하기 때문이다